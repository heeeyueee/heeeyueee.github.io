[{"content":" JS中的类\n  作为一个前端小白白，本篇将从最基础的部分来说~\n 前言 ​ 大多数面向对象的编程语言都支持类和类继承的特性，而JavaScript却不支持这些特性，因为JavaScript的创造者在设计JS语言时并没有借鉴从C, Java中关于类的部分，Javascript语言实际上是（简化的）函数式编程+（简化的）面向对象编程的混合产物，它不是真正的面向对象编程（OOP）语言，它的语法最初并没有class（类）。从ES1到ES5，开发者们都在使用着各种方法来实现类似的类特性，终于在ES6中引入了类的特性。\n面向对象  要理解类，我们首先需要了解面向对象编程的思想。\n ​ 面向对象（Object Oriented）是一种新兴的程序设计方法，或者是一种新的程序设计规范(paradigm)，其基本思想是使用对象、类、继承、封装、多态等基本概念来进行程序设计。从现实世界中客观存在的事物（即对象）出发来构造软件系统，并且在系统构造中尽可能运用人类的自然思维方式。\n对象 ​ 对象是系统中用来描述客观事物的一个实体，它是构成系统的一个基本单位。一个对象由一组属性和对这组属性进行操作的一组服务(方法)组成。\n　类的实例化可生成对象，一个对象的生命周期包括三个阶段：生成、使用、消除。\n类 ​ 类是具有相同属性和方法的一组对象的集合，它为属于该类的所有对象提供了统一的抽象描述，其内部包括属性和方法两个主要部分。在面向对象的编程语言中，类是一个独立的程序单位，它应该有一个类名并包括属性和方法两个主要部分。\nES5中类的实现 ​ ES5及早期版本中没有类的概念，实现近似类的方法就是创建一个自定义类型，首先创建一个构造函数，里面定义了类的属性，类的方法通过赋值给构造函数的原型来定义。最后，通过new操作符来创建一个类的实例，也就是对象。\n// 构造函数\rfunction Person(name, age) {\rthis.name = name;\rthis.age = age;\r}\r//给构造函数的原型添加方法\rPerson.prototype.running = function() {\rconsole.log(this.name + this.age + \u0026quot;running\u0026quot;);\r}\r//实例化对象\rvar p = new Person(\u0026quot;blend\u0026quot;, 18);\rp.running();  ES5中的继承 ES5的继承需要多个步骤才能实现，如下例：\n// Shape - 父类(superclass)\rfunction Shape( length，width) {\rthis.length =length ;\rthis.width = width;\r}\r// 父类的方法\rShape.prototype.getArea = function() {\rreturn this.length*this.width\r};\r// Rectangle - 子类(subclass)\rfunction Rectangle(length) {\rShape.call(this,length,length); // call super constructor.\r}\r// 子类续承父类\rRectangle.prototype = Object.create(Shape.prototype);\rRectangle.prototype.constructor = Rectangle;\rvar rect = new Rectangle();\rconsole.log('Is rect an instance of Rectangle?',\rrect instanceof Rectangle); // true\rconsole.log('Is rect an instance of Shape?',\rrect instanceof Shape); // true\rrect.getArea(1, 1); // Outputs, '1'\r ES6中的类 ES6中引入了类的特性，可以直接使用class关键字进行类声明，但实际上ES6的类声明只是基于ES5中自定义类型声明的语法糖，typeof\nPerson 最终返回的结果是 function ，所以ES6中的类声明实际上创建了一个具有构造函数方法行为的函数。👉深入理解 JavaScript 中的 class\nclass Person {\r//等价于ES5中的构造函数\rconstructor(name, age) {\rthis.name = name;\rthis.age = age;\r}\r//等价于Person.prototype.running\rrunning() {\rconsole.log(this.name + this.age + \u0026quot;running\u0026quot;);\r}\r//静态方法\rstatic create(name,age){\rreturn new Person(name,age)\r}\r}\rconst p = new Person(\u0026quot;blend\u0026quot;, 18);\rp.running();\r ⚠️特点：\n  在类中所有的方法都是不可以枚举的\n  必须通过关键字new来调用函数\n  可以使用static关键字来定义静态成员，静态方法只能通过类来直接调用，不能通过实例对象来调用\n  ES6中的继承 ES6中使用extends关键字来指定类继承的函数，使用super()方法即可以访问父类的构造函数。\n//父类\rclass Person {\rconstructor(name, age) {\rthis.name = name;\rthis.age = age;\r}\rrunning() {\rconsole.log(this.name, this.age, \u0026quot;running\u0026quot;);\r}\r}\r//子类\rclass Student extends Person {\rconstructor(name, age, sno, score) {\rsuper(name, age);\rthis.sno = sno;\rthis.score = score;\r}\rstudying() {\rconsole.log(this.name, this.age, this.sno, this.score, \u0026quot;studing\u0026quot;);\r}\r}\rconst stu = new Student1(\u0026quot;why\u0026quot;, 18, 110, 100);\rstu.studying();\r ❗️ 注意：\n 在constructor中，子类必须通过super来调用父类的构造方法，对父类进行初始化，否则会报错。 在构造函数访问this之前一定要调用super( )，它负责初始化this。  私有变量 ​ ES6 中 class 的出现拉近了 JS 和传统 OOP 语言的距离。但是在其中，比较大的一个问题就是私有变量问题，私有变量就是只能在类内部访问的变量，外部无法访问的变量。ES6中如何实现？\n可以参考下面这些博客来读一读：\n👉 JavaScript 中的私有变量\n👉ES6 系列之私有变量的实现\n","date":"2021-05-24","permalink":"https://heeeyueee.github.io/post/%E7%90%86%E8%A7%A3js%E4%B8%AD%E7%9A%84%E7%B1%BB/","tags":["JS"],"title":"理解JS中的类"},{"content":" VUE总结\n  在面试中经常被问到，工作实际中也常常使用到，立马来篇博客总结记录\n props和$emit 父组件向子组件传值 在父组件中通过props来把数据传入子组件\n  父组件中\n在子组件标签中添加自定义属性，并通过 v-bind 动态赋值绑定要传给子组件的值\n  \u0026lt;template\u0026gt;\r\u0026lt;div class=\u0026quot;parent\u0026quot;\u0026gt;\r\u0026lt;child :message=\u0026quot;childData\u0026quot;\u0026gt;\u0026lt;/child\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script\u0026gt;\rimport Child from './child'\rexport default {\rcomponents: { Child },\rdata() {\rreturn {\rchildData: \u0026quot;父传子\u0026quot;\r}\r}\r}\r\u0026lt;/script\u0026gt;\r复制代码\r   子组件中\n通过props选项来拿到父组件传输过来的值，可对值的类型和初始值进行定义\n  \u0026lt;template\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;span\u0026gt;{{message}}\u0026lt;/span\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script\u0026gt;\rexport default {\rprops:{\rmessage:{\rtype:String,\rdefault: () =\u0026gt; ''\r}\r}\r}\r\u0026lt;/script\u0026gt;\r复制代码\r 子组件向父组件传值 因为Vue是单向数据流，所以不能直接在子组件中修改父组件传输过来的值，而是子组件通过$emit来触发事件告知父组件去修改值\n  子组件中\n在相关事件触发的函数中，通过$emit来告知父组件更改数据，第一个参数是父组件中子组件标签上自定义事件的名字，第二个参数是传给父组件的值，也就是父组件中自定义事件触发函数的参数。\n  \u0026lt;template\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;span\u0026gt;{{message}}\u0026lt;/span\u0026gt;\r\u0026lt;button @click=\u0026quot;sendMsgToParent\u0026quot;\u0026gt;\r子传父\r\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script\u0026gt;\rexport default {\rprops:{\rmessage:{\rtype:String,\rdefault: () =\u0026gt; ''\r}\r},\rmethods:{\rsendMsgToParent(){\rthis.$emit(\u0026quot;listenChildEvent\u0026quot;,\u0026quot;this data is from child\u0026quot;);\r}\r}\r}\r\u0026lt;/script\u0026gt;\r复制代码\r   父组件中\n父组件中通过自定义事件绑定的函数来拿到子组件传递过来的data，进行相关值的操作\n  \u0026lt;template\u0026gt;\r\u0026lt;div class=\u0026quot;parent\u0026quot;\u0026gt;\r\u0026lt;child :message=\u0026quot;childData\u0026quot; @listenChildEvent=\u0026quot;acceptMsgFromChild\u0026quot;\u0026gt;\u0026lt;/child\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script\u0026gt;\rimport child from './child.vue';\rexport default {\rdata() {\rreturn {\rchildData: \u0026quot;父传子\u0026quot;\r};\r},\rcomponents: {\rChild\r},\rmethods:{\racceptMsgFromChild(data){\rconsole.log(data);//或者将接受值处理\r}\r}\r}\r\u0026lt;/script\u0026gt;\r复制代码\r v-model  v-model来做表单双向数据绑定，v-model=\u0026ldquo;msg\u0026quot;实则是 :value=\u0026ldquo;msg\u0026rdquo; @input=\u0026ldquo;msg = $event.target.value\u0026quot;的语法糖。所以v-model指令同时做了两件事：\n1.监听input输入事件 2.将输入的值绑定到对应数据上\n 了解v-model的自带input事件 ,在父组件中通过v-model来绑定相关数据，子组件就可以通过$emit来触发input事件，将值传递给父组件。\n 父组件中  \u0026lt;template\u0026gt;\r\u0026lt;div class=\u0026quot;parent\u0026quot;\u0026gt;\r\u0026lt;child v-model=\u0026quot;data\u0026quot;\u0026gt;\u0026lt;/child\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script\u0026gt;\rimport child from './child.vue';\rexport default {\rdata() {\rreturn {\rdata: \u0026quot;父子间v-model通信\u0026quot;\r};\r},\rcomponents: {\rChild\r}\r}\r\u0026lt;/script\u0026gt;\r复制代码\r  子组件中  1.通过点击事件来触发父子组件数据同步\n2.父组件中 v-model 绑定的值，只能通过value 这个属性名来传输\n3.通过$emit来触发父组件v-model的input事件，第二个参数就是传给父组件将要更新的值\n\u0026lt;template\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;span\u0026gt;{{value}}\u0026lt;/span\u0026gt;\r\u0026lt;button @click=\u0026quot;shareMsgToParent\u0026quot;\u0026gt;数据同步\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script\u0026gt;\rexport default {\rprops:{\rvalue:{\rtype:String,\rdefault: () =\u0026gt; ''\r}\r},\rmethods:{\rshareMsgToParent(){\rthis.$emit(\u0026quot;input\u0026quot;,\u0026quot;this data is from child\u0026quot;);\r}\r}\r}\r\u0026lt;/script\u0026gt;\r复制代码\r  上面的操作限制了我们必须props接收的属性名为value和emit触发的必须为input，这样就容易有冲突，所以，为了更优雅的使用v-model通信而解决冲突的问题，我们可以通过在子组件中使用model选项,来定义属性名和要触发的事件名\n  子组件中使用v-model  \u0026lt;template\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;span\u0026gt;{{checked}}\u0026lt;/span\u0026gt;\r\u0026lt;button @click=\u0026quot;shareMsgToParent\u0026quot;\u0026gt;数据同步\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script\u0026gt;\rexport default {\rmodel: {\rprop: 'checked',\revent: 'change'\r},\rprops:{\rvalue:{\rtype:String,\rdefault: () =\u0026gt; ''\r}\r},\rmethods:{\rshareMsgToParent(){\rthis.$emit(\u0026quot;change\u0026quot;,\u0026quot;this data is from child\u0026quot;);\r}\r}\r}\r\u0026lt;/script\u0026gt;\r复制代码\r PS: 双向数据绑定的方法还有.sync 在另外一篇博客中有总结查看\n$attrs 和 $listeners 可以将父组件的数据传递给子孙组件，适用于只传递数据不做中间件处理的时候，但在项目中很少用到，简单了解即可。\n $attrs  包含了父作用域中不被认为 (且不预期为) props 的特性绑定 (class 和 style 除外)，并且可以通过 v-bind=”$attrs” 传入内部组件。当一个组件没有声明任何 props 时，它包含所有父作用域的绑定 (class 和 style 除外)。\n $listeners  包含了父作用域中的 (不含 .native 修饰符) v-on 事件监听器。它可以通过 v-on=”$listeners” 传入内部组件。它是一个对象，里面包含了作用在这个组件上的所有事件监听器，相当于子组件继承了父组件的事件。\n简单来说，$attrs是用来获取父组件中的属性数据的，$listeners是用来获取父组件中的事件\n 父组件  \u0026lt;template\u0026gt;\r\u0026lt;child :name=\u0026quot;name\u0026quot; :message=\u0026quot;message\u0026quot; @sayHello=\u0026quot;sayHello\u0026quot;\u0026gt;\u0026lt;/child\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script\u0026gt;\rexport default {\rinheritAttrs: false,\rdata() {\rreturn {\rname: '通信',\rmessage: 'Hi',\r}\r},\rmethods: {\rsayHello(mes) {\rconsole.log('mes', mes) // =\u0026gt; \u0026quot;hello\u0026quot;\r},\r},\r}\r\u0026lt;/script\u0026gt;\r复制代码\r  子组件  \u0026lt;template\u0026gt;\r\u0026lt;grandchild v-bind=\u0026quot;$attrs\u0026quot; v-on=\u0026quot;$listeners\u0026quot;\u0026gt;\u0026lt;/grandchild\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script\u0026gt;\rexport default {\rdata() {\rreturn {}\r},\rprops: {\rname,\r},\rcreated() {\rconsole.log(this.$attrs); // 结果： message, 因为父组件共传来name, message两个值，由于name被 props接收了，所以只有message属性\rconsole.log(this.$listeners); // sayHello: f\r}\r}\r\u0026lt;/script\u0026gt;\r复制代码\r  孙组件  \u0026lt;template\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script\u0026gt;\rexport default {\rcreated() {\rconsole.log(this.$attrs); // name,message console.log(this.$listeners) // sayHello: f\rthis.$emit('sayHello', 'hello')//可以触发 father 组件中的sayHello函数\r},\r}\r\u0026lt;/script\u0026gt;\r复制代码\r $parent 和 $children 子组件可以用 this.$parent 访问父组件，子组件被推入父组件的 $children 数组中。\n 官方提示：节制地使用 $parent 和 $children - 它们的主要目的是作为访问组件的应急方法。更推荐用 props 和 events 实现父子组件通信，并且$children不保证顺序也不是响应式的。\n  父组件  \u0026lt;template\u0026gt;\r\u0026lt;div class=\u0026quot;father\u0026quot;\u0026gt;\r\u0026lt;child\u0026gt;\u0026lt;/child\u0026gt;\r\u0026lt;button @click=\u0026quot;name\u0026quot;\u0026gt;点击改变子组件的值\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script\u0026gt;\rimport child from './child'\rexport default {\rcomponents: { child },\rdata() {\rreturn {\rmsg: '父组件message'\r}\r},\rmethods:{\rname(){\rthis.$children[0].message = \u0026quot;hello\u0026quot;\r}\r}\r}\r\u0026lt;/script\u0026gt;\r复制代码\r  子组件  \u0026lt;template\u0026gt;\r\u0026lt;div class=\u0026quot;com_a\u0026quot;\u0026gt;\r\u0026lt;span\u0026gt;{{message}}\u0026lt;/span\u0026gt;\r\u0026lt;p\u0026gt;获取父组件的值：{{parentVal}}\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script\u0026gt;\rexport default {\rdata(){\rreturn {\rmessage:'子组件message'\r}\r},\rcomputed:{\rparentVal(){\rreturn this.$parent.msg;\r}\r}\r}\r\u0026lt;/script\u0026gt;\r复制代码\r EventBus 在小型的项目中使用，\n1.在入口函数中初始化evnetBus，将一个新的vue实例放在原型链上作为全局的$eventBus\nVue.prototype.$eventBus = new Vue()\r复制代码\r 2.实例化的vue自带$on、$emit和$off方法\nhis.$eventBus.$emit('nameOfEvent', { ... pass some event data ...});//创建发出的事件\rthis.$eventBus.$on('nameOfEvent',($event) =\u0026gt; {\r// ...\r}) // 监听事件\rthis.$eventBus.$off('nameOfEvent') //移除事件监听\r复制代码\r provide和inject 父组件通过provide以对象的形式向子组件暴露一些属性，子组件通过inject注入相应属性。\n  祖先组件\nprovide选项：一个对象或返回一个对象的函数。该对象包含可注入其子孙的 property。\n  \u0026lt;template\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;child prop=\u0026quot;data\u0026quot;\u0026gt;\u0026lt;/child\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script\u0026gt;\rexport default {\rprovide: {\rname: 'Tom'\r}\r}\r复制代码\r   后代组件\ninject选项：一个字符串数组或一个对象，对象的 key 是本地的绑定名，value是注入内容的key\n  \u0026lt;template\u0026gt;\r\u0026lt;div\u0026gt;\r{{name}}\r\u0026lt;/div\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script\u0026gt;\rexport default {\rname: 'child',\rinject: [name]\r}\r\u0026lt;/script\u0026gt;\r复制代码\r 注意的点  provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。\n Vue 不会对 provide 中的变量进行响应式处理。所以，要想 inject 接受的变量是响应式的，provide 提供的变量本身就需要是响应式的。vue组件中的状态就是可响应的，直接在根组件中将组件本身注入 provide，就可以在后代组件中任意访问根组件中的所有状态，根组件就成为了全局状态的容器\n provide 和 inject 主要在开发高阶插件/组件库时使用。并不推荐用于普通应用程序代码中。\n 原因：provide/inject 中变量的修改是无法控制的，并且它破坏了vue的单向数据流，多个后代依赖了同一个祖先的状态，只要一个后代对状态进行了改变，则其他的组件都会受到影响，所以最好不要使用 provide/inject 做全局状态管理，而是使用可以追踪回溯的vuex。\nvuex Vuex是一个状态管理的插件，可以解决不同组件之间的数据共享和数据持久化，适用于大型项目。\n State：存储状态数据 Getter：从状态数据派生数据，相当于State的计算属性。 Mutation：存储用于同步更改状态数据的方法，默认传入的参数为state。 Action：存储用于异步更改状态数据，但不是直接更改，而是通过触发Mutation方法实现，默认参数为context。 Module：Vuex模块化。  vuex知识点较多，日后再学习总结~\n总结  父子间通信最常用的就是props/$emit和v-model 如果是嵌套组件通信，开发组件库可以使用provide/inject，中小型项目可以使用EventBus 大型项目中使用vuex来进行兄弟之间和跨级之间通信  参考博客 聊聊 Vue 中 provide/inject 的应用\n作者：Blend 链接：https://juejin.cn/post/6950088782381056013 来源：掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n","date":"2021-04-18","permalink":"https://heeeyueee.github.io/post/vue%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/","tags":["Vue"],"title":"VUE组件间通信方式总结"},{"content":" 前端实习生面试总结\n 大大小小的公司加起来大概有十面，总结一下常问到的题和准备时用到的资源，就继续滚去学习了\nJS  闭包（必考）一定要深入理解，各种使用到的场景，比如模块化 this的指向 apply，call，bind 箭头函数和普通函数的区别 JS数据类型，介绍bigint，symbol 如何判断数据类型 深拷贝与浅拷贝 说说你用到的ES6 let暂时性死区 Set，Map，WeakSet，WeakMap （特性和使用的场景） JS中for循环的几种形式及区别 数组去重的方法（分析各种方法的时间复杂度） Promise（必考）深入 Promise.all() Promise.race() 使用场景 async与await JS中的类，怎么实现 ES5中的继承和ES6中的继承 函数柯里化+对函数式编程的理解 Event loop 宏任务 微任务 JS中的异步编程  DOM  事件委托 冒泡和捕获 （顺序，如何取消冒泡） addEventListener的参数和使用  CSS   场景题\n在移动端实现一个正方形，离屏幕左右间距都是30px\n各种居中\n如何画三角形（多种方法）画梯形\n两栏布局\n  css定位：position属性（absolute的定位）\n  flex的各种属性\n  清除浮动的方法\n  选择器优先级\n  移动端适配 rem原理\n  CSS动画 transition的属性 transform的值\n  HTML  HTML常用行级标签和块级标签 （区别） HTML5语义化标签的优点  网络  三次握手 四次挥手（为什么是三次，四次） http与https https的加密通信原理 http请求方法 简单请求和非简单请求，Option请求 http状态码 301和302的区别 （具体到使用场景） 强缓存和协商缓存 （一定要深入了解，具体到Cache-Control中no-cache和no-store的区别） cookie，localStorage， sessionStorage三者区别 跨域的解决方法（jsonp的详细实现过程） TCP和UDP的区别  浏览器  输入url后的整个过程 CSS和JS阻塞浏览器渲染吗 回流和重绘 前端性能优化  webpack 如果只配置过，千万不要写到技能里！\n Loader和Plugin的区别 webpack你用过哪些插件（会考察细节的使用） Babel原理 模块打包原理  Vue  VUE中组件之间如何通信 说说如何实现Event bus Vue2和Vue3的响应式数据原理（Proxy使用过吗？具体如何实现的？） vue生命周期 vuerouter hash路由和history路由实现原理 计算属性computed以及里面的getter和setter v-if和v-show的区别 vue2和vue3的区别，vue3的新特性 vue3里的ref和reactive vuex的使用 vue和react区别 如何简单实现vuex（描述思路）  React 没学好，问得不多~\n React如何实现组件间通讯 React hooks  算法  排序（冒泡和快排最常考） 二叉树的种类 深度优先搜索和广度优先搜索怎么实现 用什么数据结构  学习资源 ECMAScript 6 入门\n前端高频面试精粹\n神三元\n前端知识分享\nawesome-coding-js\n关于webpack的面试题总结\n前端剑指offer\n总结 前端实习生面试 ，大多考察的是基础，学习的时候不要浮于表面，像JS中实现继承，我就只看过博客，并没有自己去动手实现过，面试官一段问起来就虚了，这次面试让我发现了很多知识都学习得不够深入，面试官一问原理什么的，就完犊子了，不说了，抓紧学习去，加油啊，铁铁们！\n","date":"2021-03-29","permalink":"https://heeeyueee.github.io/post/%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0%E7%94%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/","tags":["面试"],"title":"前端实习生面试总结"},{"content":" JS中的this\n 前言 🤟先来了解一下this的起源：\n写函数时，在还不知道对象的名字（对象还没有声明）时拿到一个对象的属性，可以怎么做呢？ 第一种：使用形式参数，调用函数的时候再传入 ，python使用了这个方法\nlet person = {\rname: 'moji',\rsayHi(p){\rconsole.log(`你好，我叫` + p.name)\r}\r}\rperson.sayHi(person)  这显然和 JS 中对象调用函数的方式不一样，JS中是直接person.sayHi()\n​ 第二种：JS解决方法是，在每个函数里加入了this，可以使用this来调用还不知道名字的对象的属性值，在被对象调用时，this里的值就是对象的地址，使用this来获取对未知对象的引用。\nlet person = {\rname: 'moji',\rsayHi(this(省略)){\rconsole.log(`你好，我叫` + this.name)\r}\r}\rperson.sayHi()\r person.sayHi()会隐式地把 person（person 是个地址） 作为 this 传给 sayHi，这样，每个函数都能用 this 获取一个未知对象的引用了。\n🤏简单来说，this就是最终调用函数的对象\nps：函数里不给其他条件，this默认指向window，箭头函数自己没有this，函数外面的this就函数里调用的this，call也无法使用\n如何确定this 最重要的是this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用！\n方法一：转换代码 参考博客\n把函数调用的方式变为使用call调用的方式\nfunc.call(context, p1, p2)\r this，就是上面代码中的 context，它是执行上下文的一个属性。执行上下文是当一个函数被调用时，被创建用于记录函数在哪里调用（调用栈），函数的调用方式，传入的参数等信息。\n例如：\nfunc(p1, p2) 等价于\rfunc.call(undefined, p1, p2)\robj.child.method(p1, p2) 等价于\robj.child.method.call(obj.child, p1, p2)\r 如果传的 context 是 null 或 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined）\n方法二：使用《你不知道的JavaScript(上)》中的准则  首先，需要找到这个函数的直接调用位置 找到之后就可以顺序应用下面四条规则来判断this的绑定对象   由new调用——绑定到新创建的对象 由call、apply、bind调用——绑定到指定的对象 由上下文对象调用——绑定到那个上下文对象（可以通过上面的转换代码的方式判断上下文对象） 默认：在严格模式下绑定到undefined，否则绑定到全局对象  一些特例 [ ] 语法 function fn (){ console.log(this) }\rvar arr = [fn, fn2]\rarr[0]() // 这里面的 this 又是什么呢？\r 我们可以把 arr[0]() 想象为arr.0()，虽然后者的语法错了，但是形式与转换代码里的 obj.child.method(p1, p2) 对应上了，于是就可以愉快的转换了：\narr[0]() 假想为 arr.0()\r然后转换为 arr.0.call(arr)\r那么里面的 this 就是 arr 了 :)\r 箭头函数 箭头函数里并没有 this，箭头函数会继承外层函数调用this绑定，如果在箭头函数里看到 this，直接把它当作箭头函数外面的 this 即可。\ncall()、apply()、bind()用法 可以使用call / apply / bind 来强制指定 this 的值\ncall()和apply() call 方法第一个参数也是作为函数上下文的对象，后面传入的是一个参数列表，而不是单个数组。\napply 方法传入两个参数：一个是作为函数上下文的对象，另外一个是作为函数参数所组成的数组。\n作用：\n  改变this的指向\n  调用函数\nperson.sayHi()=person.sayHi.call(person) ，不需要传this时，使用undefined来占位\n  bind() 它和 call 很相似，接受的参数有两部分，第一个参数是是作为函数上下文的对象，第二部分参数是个列表，可以接受多个参数。使用bind来绑定this，让this不再改变\n面试题 参考 关于this的两道面试题和三篇文章\nthis 的值到底是什么？一次说清楚\n你怎么还没搞懂 this？\nJS 里为什么会有 this\n","date":"2021-01-31","permalink":"https://heeeyueee.github.io/post/%E7%90%86%E8%A7%A3js%E4%B8%AD%E7%9A%84this/","tags":["JS"],"title":"理解JS中的this"},{"content":" JS中的继承\n 面向对象编程很重要的一个方面，就是对象的继承。A 对象通过继承 B 对象，就能直接拥有 B 对象的所有属性和方法。但Javascript之父在设计语言时，为了使语言轻便，没有引入类的概念，而是通过“原型对象”（prototype）实现。JS中常见的继承方式有基于原型链继承，基于构造函数继承和基于 class 的继承\n1.原型链继承 子类型的原型为父类型的一个实例对象\n模板如下， ⭕️核心就是把子类的prototype设置为父类的实例\n// 父类\rfunction Person() {}\r// 子类\rfunction Student(){}\r// 继承\rStudent.prototype = new Person()\r 👇下面来看一个实例：\n//父类型\rfunction Person(name, age) {\rthis.name = name,\rthis.age = age,\rthis.play = [1, 2, 3]\rthis.setName = function () { }\r}\rPerson.prototype.setAge = function () { }\r//子类型\rfunction Student(price) {\rthis.price = price\rthis.setScore = function () { }\r}\r// 子类型的原型为父类型的一个实例对象\rStudent.prototype = new Person() var s1 = new Student(15000)\rvar s2 = new Student(14000)\rs1.play.push(4)\rconsole.log(s1,s2)\r 打印出来的结果：\n可以看到只对s1进行play的修改，s2中的play也发生了变化，这是就是原型链继承的缺点父类的引用属性会被所有子类实例共享。\n还有一个缺点就是子类构建实例时不能向父类传递参数。但优点是父类方法可以复用，比如上述的setAge。\n2.构造函数继承 在子类型构造函数中通用call()调用父类型构造函数\n⭕️核心就是在子类(Student)里执行Person.call(this)，将父类构造函数的内容复制给了子类的构造函数。\n👇下面来看一个实例：\nfunction Person(name, age) {\rthis.name = name,\rthis.age = age,\rthis.setName = function () {}\r}\rfunction Student(name, age, price) {\rPerson.call(this, name, age) // 相当于: this.Person(name, age)\r/*this.name = name\rthis.age = age*/\rthis.price = price\r}\rvar s1 = new Student('Tom', 20, 15000)\rvar s2 = new Student('Lucy', 20, 15000)\rconsole.log(s1.setName === s2.setName)\r 可以发现父类的函数setName()，在子类的实例下是不共享的，构造函数继承的方式中引用属性不会被所有实例共享，构造函数继承的方式不使用prototype继承,而是在子类里面执行父类的构造函数,相当于把父类的代码复制到子类里面执行一遍,这样做的另一个好处就是可以给父类传参。\n可以发现原型链继承和构造函数继承的优缺点正好完全相反，把他们组合起来就可以得到互补的组合继承。\n3.组合继承 ⭕️组合继承,就是各取上面2种继承的长处,父类中的普通属性使用构造函数继承,函数 使用 原型链继承。\n👇下面来看一个实例：\nfunction Person(name, age) {\rthis.name = name,\rthis.age = age,\r}\rPerson.prototype.setName = function(){}\rfunction Student(name, age, price) {\rPerson.call(this, name, age) // 构造函数继承(继承属性)\rthis.price = price\r}\rStudent.prototype = new Person() // 原型链继承(继承方法)\rvar s1 = new Student('Tom', 20, 15000)\rvar s2 = new Student('Lucy', 20, 15000)\rconsole.log(s1.setName === s2.setName)\r setName()使用prototype继承就可以被所有子类实例共享\n4.原型式继承 ⭕️ object内部首先是创建了一个空的构造函数F,然后把F的prototype指向参数proto,最后返回一个F的实例对象,完成继承. 原型式继承看起来跟原型继承很像,事实上,两者因为都是基于prototype继承的,所以也有一些相同的特性,比如引用属性共享问题, 那原型式继承跟原型继承有什么区别呢? 一个比较明显的区别就是clone函数接收的参数不一定要是构造函数,也可以是其他任何对象, 这样我们就相当于是浅复制了一个对象.\nfunction object(o){\rfunction F(){}\rF.prototype = o;\rreturn new F();\r}\r 使用：\nvar person = {\rname: \u0026quot;Nicholas\u0026quot;,\rfriends: [\u0026quot;Shelby\u0026quot;, \u0026quot;Court\u0026quot;, \u0026quot;Van\u0026quot;]\r};\rvar anotherPerson = object(person);\ranotherPerson.name = \u0026quot;Greg\u0026quot;;\ranotherPerson.friends.push(\u0026quot;Rob\u0026quot;);\rvar yetAnotherPerson = object(person);\ryetAnotherPerson.name = \u0026quot;Linda\u0026quot;;\ryetAnotherPerson.friends.push(\u0026quot;Barbie\u0026quot;);\ralert(person.friends); //\u0026quot;Shelby,Court,Van,Rob,Barbie\u0026quot;\r  ECMAScript 5 通过新增 Object.create()方法规范化了原型式继承。\n 所以ES5的Object.create()函数,就是基于原型式继承的，上文中代码可以转变为\nvar yetAnotherPerson = object(person); =\u0026gt; var yetAnotherPerson = Object.create(person);\r 5.寄生组合式继承 组合继承有个缺点,就是父类构造函数里面的代码会执行2遍.\n 第一次：Student.prototype = new Person()   ‘new 的过程’的第三步，其实就是执行了父类构造函数。\n复习new的过程\n  第二次： Person.call(this, name, age)   call的作用是改变函数执行时的上下文。比如：A.call(B)。其实，最终执行的还是A函数，只不过是用B来调用而已。所以，你就懂了Parent.call(this,name,like) ,也就是执行了父类构造函数。\n 可以用寄生组合式继承来解决这个问题\nfunction inherit(sub, super){\rlet prototype = clone(super.prototype)\rprototype.constructor = sub sub.prototype = prototype }\r 这样我们就实现了一个寄生组合式继承的函数inherit,接下来我们来使用一下:\nfunction Person(name){}\rfunction Student(){\rSuperType.call(this)\r}\rinherit(Student, Person)\r 我们用 inherit 函数替换了 Student.prototype = new Person() ,从而避免了执行 new Person().\n这是一种完美的继承方式。\n6.class 的继承 ES6中引入了class关键字，class可以通过extends关键字实现继承,class关键字只是原型的语法糖，JavaScript继承仍然是基于原型实现的\n⭕️ES6先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。\n👇下面来看一个实例：\nclass Person {\r//调用类的构造方法\rconstructor(name, age) {\rthis.name = name\rthis.age = age\r}\r//定义一般的方法\rshowName() {\rconsole.log(\u0026quot;调用父类的方法\u0026quot;)\rconsole.log(this.name, this.age);\r}\r}\rlet p1 = new Person('kobe', 39)\rconsole.log(p1)\r//定义一个子类\rclass Student extends Person {\rconstructor(name, age, salary) {\rsuper(name, age)//通过super调用父类的构造方法\rthis.salary = salary\r}\rshowName() {//在子类自身定义方法\rconsole.log(\u0026quot;调用子类的方法\u0026quot;)\rconsole.log(this.name, this.age, this.salary);\r}\r}\rlet s1 = new Student('wade', 38, 1000000000)\r","date":"2021-01-30","permalink":"https://heeeyueee.github.io/post/%E7%90%86%E8%A7%A3js%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/","tags":["JS"],"title":"理解JS中的继承"},{"content":" SCSS语法小抄\n  最近在VUE的项目中使用到了SCSS，总结一些基础的语法。\n 安装 在控制台直接输入命令：\nyarn add sass\r 在vue文件的style标签中写上 lang=\u0026quot;scss\u0026quot;就可以开始啦\n变量 Scss通过$关键字声明和使用一个变量,频繁使用的color、radius、长度等数据可以声明为变量放在头部。\n 举例  $h: 32px;\r$border-color: #d9d9d9;\r$color: #333;\r$blue: #40a9ff;\r$radius: 4px;\r$red: red;\r 操作符 SASS提供了标准的算术运算符，例如+、-、*、/、%，可以采用运算符直接对数据进行处理。\n.test{\rwidth:$h*2;\rborder-radius: $h/2;\r}\r 插值语句 #{} 插值语句的作用：\n 可以在选择器或属性名中使用变量：  $name: foo;\r$attr: border;\rp.#{$name} {\r#{$attr}-color: blue;\r}\r 在有引号的文本字符串中使用 #{} 插值语句可以添加动态的值：  p:before {\rcontent: \u0026quot;I ate #{5 + 10} pies!\u0026quot;;\r}\r 在calc()函数中使用变量  \u0026amp;.test \u0026gt;span{\rleft:calc(100% - #{$h2} - 2px);\r}\r 嵌套  Sass 允许将一套 CSS 样式嵌套进另一套样式中，内层的样式将它外层的选择器作为父选择器  ​ 在嵌套规则中可以写任何css代码，包括群组选择器（,），子代选择器（\u0026gt;），同层相邻组合选择器（+）、同层全体组合选择器（~）\n/* --------------------SCSS---------------- */\r#test {\rwidth: 97%;\r\u0026gt;.son {\rbackground-color: #ff0000;\r}\r}\r/* --------------------CSS---------------- */\r#test {\rwidth: 97%;\r}\r#test \u0026gt;.son {\rbackground-color: #ff0000;\r}\r 父选择器 \u0026amp;   \u0026amp; =嵌套规则外层的父选择器，有多层嵌套时 ，最外层的父选择器会一层一层向下传递，\u0026amp;=级联的祖辈选择器。 使用伪类选择器时，需要直接使用嵌套外层的父选择器  /* --------------------SCSS---------------- */\r#main {\rcolor: black;\ra {\rfont-weight: bold;\r\u0026amp;:hover { color: red; }\r}\r}\r/* --------------------CSS---------------- */\r#main {\rcolor: black; }\r#main a {\rfont-weight: bold; }\r#main a:hover {\rcolor: red; }\r  作为选择器的第一个字符，其后跟随后缀生成复合的选择器  /* --------------------SCSS---------------- */\r#main {\rcolor: black;\r\u0026amp;-sidebar { border: 1px solid; }\r}\r/* --------------------CSS---------------- */\r#main {\rcolor: black; }\r#main-sidebar {\rborder: 1px solid; }\r 属性嵌套  ​ 有些 CSS 属性遵循相同的命名空间 (namespace)，如font-XXX，border-XXX等等，都可以以开头的单词作为属性的命名空间进行嵌套。\n/* --------------------SCSS---------------- */\r.funky {\rfont: {\rfamily: fantasy;\rsize: 30em;\rweight: bold;\r}\r}\r/* --------------------CSS---------------- */\r.funky {\rfont-family: fantasy;\rfont-size: 30em;\rfont-weight: bold; }\r 混合（Mixin) 对于经常重复使用的代码，使用混合Mixin可以“一次声明，随处引用”\n定义 @mixin 后添加名称与样式\n举例：在float布局中经常要给父元素加上.clearfix\n@mixin clearfix {\r\u0026amp;:after {\rcontent: '';\rdisplay: block;\rclear: both;\r}\r}\r 引用 使用 @include 指令引用混合样式\n#parent {\r@include clearfix;\rpadding: 4px;\rmargin-top: 10px;\r}\r Minix指令还可以接受参数等等\n继承 SCSS继承可以让一套样式作用于不同的元素，减少代码的重复。\n定义 使用 %定义继承样式\n%border-style {\rborder:1px solid red;\r}\r 使用 通过关键字@extend完成继承\n.container {\r@extend %border-style;\r}\r 不同 与混合不一样的是，混合编译为CSS后，会在每个引入混合样式的选择器下插入样式，而继承则是把继承的选择器加入到共有的样式选择器前，不会被编译到 CSS 文件中。\n SCSS\n /* --------------------Mixin---------------- */\r@mixin border-style {\rborder:1px solid red;\r}\r.container {\r@include %border-style;\r}\r.test {\r@include %border-style;\r}\r/* --------------------extend---------------- */\r%border-style {\rborder:1px solid red;\r}\r.container {\r@extend %border-style;\r}\r.test {\r@extend %border-style;\r}\r  编译为css后\n  混合中  .container {\rborder:1px solid red;\rborder-radius: 5px;\r}\r.test {\rborder:1px solid red;\rborder-radius: 5px;\r}\r  继承中  .container, .test {\rborder:1px solid red;\rborder-radius: 5px;\r}\r","date":"2021-01-28","permalink":"https://heeeyueee.github.io/post/%E5%AD%A6%E4%B9%A0scss%E8%AF%AD%E6%B3%95/","tags":["SCSS"],"title":"简单总结SCSS语法"},{"content":" sync\n 前言 当我们在子组件中想要修改通过props绑定的外部组件里的数据时，Vue不支持我们直接在子组件中进行修改，子组件没有修改父组件数据的权力，推荐我们利用EventBus事件中心，在vue实例上就含有$emit接口来触发事件，$on来监听响应事件，$off来移除事件的监听，所以在子组件中使用this.$emit()来触发事件，并把修改后的值作为参数传入，Vue会把传入的参数保存到$event中，父组件响应事件并通过$event来取值实现数据的更新，避免由子组件直接修改父组件传过来的内容。\n官方示例\n举个例子，在一个包含 title prop 的组件中，通过$emit来触发\u0026rsquo;update:title\u0026rsquo;事件，向父组件发送数据更新消息：\nthis.$emit('update:title', newTitle)\r 然后父组件中可以监听\u0026rsquo;update:title\u0026rsquo;事件并根据需要更新一个本地的数据 property。\n\u0026lt;text-document\rv-bind:title=\u0026quot;doc.title\u0026quot;\rv-on:update:title=\u0026quot;doc.title = $event\u0026quot;\r\u0026gt;\u0026lt;/text-document\u0026gt;\r  v-on:update:title=\u0026quot;doc.title = $event\u0026quot;这一长串在模版中显得十分笨重，而且父子间通信是常用的操作，模版中要是出现很多类似语句就违反了Vue简洁的出发点，所以Vue就推出了sync修饰符~\n使用 Vue为上面的模式提供一个缩写，即 .sync 修饰符，.sync 修饰符就是事件绑定的语法糖：\n\u0026lt;text-document :title.sync=\u0026quot;doc.title\u0026quot;\u0026gt;\u0026lt;/text-document\u0026gt;\r 上面的例子通过sync修饰符简化后里面就变得简单明了\n示例 下面通过一个父子组件通信的例子来掌握sync修饰符的用法\n父组件将money值传给子组件，子组件不能直接修改money值，必须要触发事件来告知父组件修改后的money值，在父组件中监听到事件后确认修改对应的money的值，有v-on的写法和使用sync修饰符简写的语法。\n子组件\nchild.vue\n\u0026lt;template\u0026gt;\r\u0026lt;div class=\u0026quot;child\u0026quot;\u0026gt;\r{{money}}\r\u0026lt;button @click=\u0026quot;$emit('update:money', money-100)\u0026quot;\u0026gt;\r\u0026lt;span\u0026gt;子组件花100元\u0026lt;/span\u0026gt;\r\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script\u0026gt;\rexport default {\rprops: [\u0026quot;money\u0026quot;]\r};\r\u0026lt;/script\u0026gt;\r\u0026lt;style\u0026gt;\r.child {\rborder: 3px solid green;\r}\r\u0026lt;/style\u0026gt;\r 父组件\napp.vue\n\u0026lt;template\u0026gt;\r\u0026lt;div class=\u0026quot;app\u0026quot;\u0026gt;\r父组件：我现在有 {{total}}元\r\u0026lt;hr\u0026gt;\r\u0026lt;!-- 语法糖式写法 --\u0026gt;\r\u0026lt;!-- \u0026lt;Child :money.sync=\u0026quot;total\u0026quot;/\u0026gt; --\u0026gt;\r\u0026lt;Child :money=\u0026quot;total\u0026quot; v-on:update:money=\u0026quot;total = $event\u0026quot;/\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script\u0026gt;\rimport Child from \u0026quot;./Child.vue\u0026quot;;\rexport default {\rdata() {\rreturn { total: 10000 };\r},\rcomponents: { Child: Child }\r};\r\u0026lt;/script\u0026gt;\r\u0026lt;style\u0026gt;\r.app {\rborder: 3px solid red;\rpadding: 10px;\r}\r\u0026lt;/style\u0026gt;\r  事件的名称最好写为update:mondy，update是vue规定的语法书写格式，money是被绑定事件的属性。 代码会被扩展成（自动更新父组件属性的 v-on 监听器），就是一个语法糖。  vue3升级改变 在 Vue 2.0 中， v-model 指令只能为 value 的 prop进行双向绑定，但如果我们对其他的 prop进行双向，就不得不使用 v-bind.sync，如上面实例中的money。\n在vue3对v-model做出了升级改变！\n 在 Vue 3 中，双向数据绑定的 API 已经标准化，减少了开发者在使用 v-model 指令时的混淆并且在使用 v-model 指令时可以更加灵活。\n 所以上例父组件中：\n原始版本：\n\u0026lt;Child :money=\u0026quot;total\u0026quot; v-on:update:money=\u0026quot;total = $event\u0026quot;/\u0026gt;\r 使用v-bind.sync：\n\u0026lt;Child :money.sync=\u0026quot;total\u0026quot;/\u0026gt;\r vue3中使用v-model：\n\u0026lt;Child v-model:money=\u0026quot;total\u0026quot;/\u0026gt;\r 参考官方文档：vue3:v-model\n","date":"2021-01-01","permalink":"https://heeeyueee.github.io/post/%E7%90%86%E8%A7%A3vue%E4%BF%AE%E9%A5%B0%E7%AC%A6sync/","tags":["Vue"],"title":"理解Vue修饰符sync"},{"content":" computed 、watch\n  2020年的最后一篇博客了，记录一下Vue中computed和watch的用法和区别\n computed 前言：Vue模版（template）中的表达式{{}}可以直接放入简单的运算，如 {{ msg.split('').reverse().join('') }}，但如果模版中过多的出现这样的运算语句会使模版变得逻辑复杂且冗余，会对页面的可维护性造成很大的影响。\n于是Vue变推出了计算属性computed来解决此类问题，把复杂语句放入computed中，使模板中的运算逻辑更简单。\n\u0026lt;div id=\u0026quot;example\u0026quot;\u0026gt;\r\u0026lt;p\u0026gt;Original message: \u0026quot;{{ message }}\u0026quot;\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;Computed reversed message: \u0026quot;{{ reversedMessage }}\u0026quot;\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\rvar vm = new Vue({\rel: '#example',\rdata: {\rmessage: 'Hello'\r},\rcomputed: {\r// 计算属性的 getter\rreversedMessage: function () {\r// `this` 指向 vm 实例\rreturn this.message.split('').reverse().join('')\r},\rmessagePlus: {\rget: function () {\rreturn this.message + \u0026quot;hello\u0026quot;\r},\rset: function (v) {\rthis.message = v + \u0026quot;olleh\u0026quot;\r}\r}\r}\r})\rvm.messagePlus=\u0026quot;hello\u0026quot;\r computed计算属性中\n 声明函数来读取结果值，只有只读属性，默认实现的就是getter，在模版上可以直接使用函数名来获取结果，不需要加上() 如果使用箭头函数，则this不会指向实例vm，而是会指向全局window，或gobal 如果既要读取结果又要对结果进行设置，则要在computed中声明为属性，并设置getter和setter方法  缓存 计算属性是基于它们的依赖的响应式数据进行缓存的。只在相关响应式数据发生改变时它们才会重新调用对应的getter来计算。\n上例中，只要 message 还没有发生改变，再次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。\ncomputed 应用场景\n  适用于一些重复使用数据或复杂及费时的运算。我们可以把它放入computed中进行计算, 然后会在computed中缓存起来, 下次就可以直接获取了。\n  如果我们需要的数据依赖于其他的数据的话, 我们可以把该数据设计为computed中。\n  ps:如果不想被缓存，则使用方法methods，methods方法中是每次调用, 都会执行函数\nwatch watch它是一个对data的数据监听回调, 当依赖的data的数据变化时, 会执行回调handler函数。在回调中会传入newVal和oldVal两个参数。Vue实列将会在实例化时调用$watch(), 他会遍历watch对象的每一个属性。\n用法 watch: {\robj1: function (val, oldVal) {\r...\r},\r// 方法名\robj2: 'someMethod',\r// 该回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深\robj3: {\rhandler: function (val, oldVal) { /* ... */ },\rdeep: true\r},\r// 该回调将会在侦听开始之后被立即调用,第一次渲染就触发这个函数\robj4: {\rhandler: 'someMethod',\rimmediate: true\r},\r// 可以传入回调数组，它们会被逐一调用\robj5: [\r'handle1',\rfunction handle2 (val, oldVal) { /* ... */ },\r{\rhandler: function handle3 (val, oldVal) { /* ... */ },\r/* ... */\r}\r],\r// 对obj1对象中的属性a监听\r'obj1.a': function (val, oldVal) { /* ... */ }\r}\r 选项  immediate  ​ immediate是设置第一次渲染是否要触发这个函数，默认是false(由无到有不触发，变化才触发)。\n  deep\nwatch监听数据是否发生变化的规则是：简单类型直接比较值有没有变化，复杂类型对象要看地址有没有变化\n所以当obj中的a变化了watch不会认为obj改变了，因为地址没有变，obj赋值给新地址watch才会认为改变了，如果你需要a变了，obj也要变，就可以设置deep属性为true。\ndeep的作用就是否深度监听某个对象的值, 该值默认为false，注意监听数组的变更不需要这么做。\n  注意  不应该使用箭头函数来定义 watcher 函数，因为箭头函数本身没有this，它会继承外部的this，watcher函数外部的this不会是实例vm而是全局作用域的window或者是gobal 就无法获取到实例vm内部的数据，所以要使用普通function xxx或其简写来声明watcher函数，这样当Vue调用函数时必定会传入vm来作为其this  总结   computed是计算属性，watch是监听数据的变化，再触发回调函数\n  computed是对属性的值进行计算， 在Vue的 template模板内（{{}}）使用时可以不用加括号，直接使用。它会根据依赖进行缓存 如果依赖的值不变，它就不会重新计算。\n  watch 更像是一个 data 的数据监听回调，当依赖的 data 的数据变化，执行回调，在方法中会传入 newVal 和 oldVal。watch有两个选项immediate和deep，immediate是设置第一次渲染是否要触发这个函数，默认是false，deep 设置是否监听对象内部值的变化，默认是false。\n  computed着重于依赖缓存，计算后得出结果，而watch是执行一个函数，记录变化\n ","date":"2020-12-31","permalink":"https://heeeyueee.github.io/post/%E7%90%86%E8%A7%A3vue%E4%B8%AD%E7%9A%84computed%E5%92%8Cwatch/","tags":["Vue"],"title":"理解Vue中的computed和watch"},{"content":" Vue数据响应式\n 什么是数据响应式  Vue.js 一个核心思想是数据驱动。所谓数据驱动，是指视图是由数据驱动生成的，我们对视图的修改，不会直接操作 DOM，而是通过修改数据。——《Vue.js 技术揭秘》\n 拿Vue官方教程举例来说，在Vue中我们只需要改变data中的price，页面会立马自动做出响应来显示更新后的数据。而不是像使用原生JS需要许多DOM操作才能完成。Vue是怎样监听到数据的改变让视图立马做出响应的呢？\n 上图是Vue的官方文档中的图解，黄色部分是 Vue 的渲染方法，视图初始化和视图更新时都会调用render 方法进行重新渲染。渲染时不可避免地会 touch 到每个需要展示到视图上的数据（紫色部分），触发这些数据的 get 方法从而收集到本次渲染的所有依赖。而当我们在修改这些收集到依赖的数据时，会触发数据中的 set 属性方法，该方法会修改数据的值并 notify 到依赖到它的观察者，从而触发视图的重新渲染。\n 而我们定义在data中的数据并没有set，get的计算属性，get、set方法是如何产生的呢？这便是Vue的数据响应式的核心工作，重写数据的 get 和 set 属性方法。\n让数据变成响应式  当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。\n 上面是Vue官方文档的解答，下面详细了解一下Vue如何将数据变为响应式的？\ngetter、setter let obj = {\rfirstName: \u0026quot;王\u0026quot;,\rlastName: \u0026quot;XX\u0026quot;,\rget name() {\rreturn this.firstName + this.lastName;\r},\rset name(value){\rthis.firstName = value[0]\rthis.lastName = value.slice(1)\r},\rage: 18\r};\robj.name = '王小小'\rconsole.log( obj.name);\r 如上例，getter、setter方法也可以是obj对象的属性，我们可以使用操作属性的点语法来获取name和修改name。如果在控制台进行打印就会发现 name属性下的getter、setter方法就和实例化vue中的data 里的值n打印出来变为了n:(...)也有getter、setter方法，说明vue重写数据n,将其转换为getter/setter的对象属性。\nObject.defineProperty Vue是如何将data中普通的属性n转化为getter、setter方法的属性n呢？答案是通过 JS 标准内置对象方法 Object.defineProperty 来设定的\n Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。——MDN\n Object.defineProperty(obj, prop, descriptor)\r Object.defineProperty() 接收三个参数：第一个是要定义属性的对象；第二个是要定义或修改的属性的名称或 Symbol；第三个则是要定义或修改的属性描述符。在第三个参数中，我们可以定义属性的 getter 函数和setter 函数，这便解释了Vue如何通过Object.defineProperty 把这些 data里的属性全部转为 getter/setter。\nvar obj = {}; // 创建一个新对象\r// 在对象中添加一个属性a\rObject.defineProperty(obj, \u0026quot;a\u0026quot;, {\rget() { return aValue; },\rset(newValue) { aValue = newValue; },\r});\r getter和setter对属性的读写操作进行了监控，但是我们只要知道属性名，就可以绕过getter和setter方法直接对属性进行控制，Vue利用代理模式解决了这个问题\nproxy let myData = {\rn: 0\r}\rlet data = proxy({\rdata: myData\r}) // 括号里是匿名对象，无法访问\rfunction proxy({ data } /* 解构赋值 */ ) {\r//for循环省略\rlet value = data.n\rObject.defineProperty(data, 'n', {\rget() {\rreturn value\r},\rset(newValue) {\rvalue = newValue\r}\r})\rconst obj = {}\rObject.defineProperty(obj, 'n', {\rget() {\rreturn data.n\r},\rset(value) {\rdata.n = value\r}\r})\rreturn obj // obj 就是代理\r}\r 上面的方法对每个传入的数据新增 getter/setter，此后原始的数据就会被 getter/setter 所替代，相当于复制了原始数据，这样不管是操作 let data = proxy(data); 中的 data，还是操作 myData，都会被我们的 getter/setter 所拦截。\n经过代理后的代码是不是就和实例化一个vue对象的代码很相似了\nconst vm = new Vue({ data: {} })\rlet data = proxy({data:myData})\r 所以，new Vue时Vue会遍历传入的data对象所有属性，并使用Object.defineProperty把这些属性全部转为getter/setter，这样就生成一个新的对象全权负责数据——就是实例化的Vue对象vm。这样vm会成为data 的代理，对 data 的所有属性进行监控，当数值发生改变的时候，vue就调用render函数重新渲染视图。\nVue 数据响应式的 Bug  由于 JavaScript 的限制，Vue 不能检测数组和对象的变化。——Vue文档\n 是什么？ var vm = new Vue({\rdata:{\ra:1\r}\r})\r// `vm.a` 是响应式的\rvm.b = 2\r// `vm.b` 是非响应式的\r 由于 Vue 会在初始化实例时对 property 执行 getter/setter 转化，所以 property 必须在 data 对象上存在才能让 Vue 将它转换为响应式的。而例子中的b属性是在实例化外再新添的，所以vue不能对b值的变化在视图上做出响应。但很多时候我们并不能事先知道data的所有属性，如果要新添属性怎么办呢？\n解决方法 对象 可以使用 Vue.set(object, propertyName, value) 方法向对象添加响应式 property。\nVue.set(vm.data, 'b', 2)\r 还可以使用 vm.$set 实例方法，这也是全局 Vue.set 方法的别名：\nthis.$set(this.data,'b',2)\r 数组 var vm = new Vue({\rdata: {\ritems: ['a', 'b', 'c','d']\r}\r})\r 把数组打印出来可见，vue对数组进行了改变，给数组加了一层原型，在其中Vue修改了7个方法覆盖了之前数组原型的7个方法。调用这些Vue新定义的方法时，在这些新方法里Vue会加上对新添的元素的监听（相当于进行了set操作），把新数据也进行代理，这样vue就能重新监测到数组的变化了更新UI操作\n具体的七个变更方法：（这些原始方法正好也会返回一个新数组）\n push() pop() shift() unshift() splice() sort() reverse()  关于Vue的响应式原理，还有很多需要探究的，这篇文件只是总结了数据如何变为响应式的。\n参考 深入响应式原理\nVue的数据响应式原理\n一探 Vue 数据响应式原理\n","date":"2020-12-28","permalink":"https://heeeyueee.github.io/post/%E7%90%86%E8%A7%A3vue%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F/","tags":["Vue"],"title":"理解Vue数据响应式"},{"content":" 入门Vue\n  在VUE官网学习使用VUE第一步——安装，就被两种不同版本的VUE绕晕了，现在通过代码和实践来总结一下不同版本的区别和如何安装使用VUE\n Vue的安装 Vue本质上是一个JS库，对于我们小白来说，通常都是直接使用VUE脚手架Vue-cli来直接安装Vue,在Vue的官方文档中给出了多种安装使用Vue的方式\n直接用\u0026lt;script\u0026gt;标签 引入 在BootCDN等网站直接下载或复制链接用 \u0026lt;script\u0026gt; 标签引入，Vue 会被注册为一个全局变量。\n完整版\n\u0026lt;script src=\u0026quot;https://cdn.bootcdn.net/ajax/libs/vue/3.0.2/vue.global.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r 非完整版\n\u0026lt;script src=\u0026quot;https://cdn.bootcdn.net/ajax/libs/vue/3.0.2/vue.runtime.global.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r 基于构建工具webpack引入 首先要先通过npm进行安装\n$ npm install vue\r 再通过在配置文件webpack.config.js文件中配置别名alias（用于vue2中）\n//完整版 resolve:{\ralias:{\r'vue':'vue/dist/vue.esm.js'\r}\r}\r//非完整版\tresolve:{\ralias:{\r'vue':'vue/dist/vue.runtime.esm.js'\r}\r}\r 使用命令行工具vue-cli引入 在使用vue-cli脚手架构建项目时，会遇到一个选项Vue build(vue构建)，有两个选项，Runtime + Compiler和Runtime-only,\nRuntime + Compiler对应完整版Vue Runtime-only对应非完整版Vue\n默认安装Runtime-only非完整版Vue\n两种版本的区别 通过学习安装Vue我们可以发现有两种版本可以选择 ：一种是完整版，一种是非完整版官方称为运行时版\n直接分别使用两种方法构建一个项目看看区别，构建完成后，对比发现只有main.js不同，如下所示\n完整版\nimport Vue from 'vue'\rimport App from './App'\rVue.config.productionTip = false\rnew Vue({\rel: '#app',\rcomponents: { App },\rtemplate: '\u0026lt;App/\u0026gt;'\r})\r 完整版可以直接在main.js的template标签中写入HTML代码，渲染到视图或修改index.html中的代码都可以直接渲染到视图。\n运行时版\nimport Vue from 'vue'\rimport App from './App'\rVue.config.productionTip = false\rnew Vue({\rel: '#app',\rrender: h =\u0026gt; h(App)\r})\r 非完整版的main.js中没有template标签不能从html直接变为视图， 必须要经过render函数创建元素。\n通过一张表格直接总结两者的区别\n   区别 完整版 运行时版     特点 同时包含编译器和运行时的版本 除去编译器的其它一切   视图 写在HTML里或写在template选项里 写在render函数里用h 来创建标签   体积 有编译器导致体积大 功能独立 体积比完整版小30%    完整版\n需要使用compiler编译器把HTML中复杂的占位符， 条件语句变为真实的DOM节点，下一次对数据的改变后需要渲染到页面就会直接操作经过编译DOM元素\n// 需要编译器\rnew Vue({\rtemplate: '\u0026lt;div\u0026gt;{{ hi }}\u0026lt;/div\u0026gt;'\r})\r 运行时版\n非完整版不能从html直接变为视图 必须要经过render函数创建元素才可以\n// 不需要编译器\rnew Vue({\rrender (h) {\rreturn h('div', this.hi)\r}\r})\r 怎样选择 完整版功能强大体积大，运行时版体积小功能独立，在项目开发时到底应该怎样选择呢？\n最佳实践是使用运行时版本，运行时版结合webpack的vue-loader，在编写代码时仍然在*.Vue文件（单文件组件）中使用template模板编写代码，最后打包（build）时vue-loader会自动加载*.Vue文件转化为render函数创建DOM元素的方式，这样即方便了我们写代码，又同时让用户可以依赖体积更小更独立的Vue，相当于我们通过打包的时候使用webpack的vue-loader进行了一次翻译来顶替了comliper编译器的功能，打好的包里就不需要编译器的，所以只用运行时版本即可。\n所以，我们先在vue单文件中的template标签中书写HTML代码\n\u0026lt;template\u0026gt;\r\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r{{n}}\r\u0026lt;button @click=\u0026quot;add\u0026quot;\u0026gt;+1\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/template\u0026gt;\r 在创建vue实例时引入vue文件，通过render函数来创建视图\nimport Vue from 'vue'\rimport App from './App.vue'\rVue.config.productionTip = false\rnew Vue({\rrender: h =\u0026gt; h(App),\r}).$mount('#app')\r codesandbox 的使用 有种更简单的方法创建Vue项目\n使用codesandbox 直接选择Vue创建项目，十分方便快速，还可以实时预览\n最后，可以通过下载压缩包的形式导出项目\n","date":"2020-12-27","permalink":"https://heeeyueee.github.io/post/vue%E8%B5%B7%E6%89%8B/","tags":["Vue"],"title":"Vue两个版本的区别"},{"content":" M,V,C\n MVC是什么 MVC是一种经典的软件架构模式，从学习Java、andriod到学习JavaScript，都遇到过它，再一次来学习它的概念：\nMVC全称Model–view–controller，将应用程序分为三个部分：Model（模型）、View（视图）和Controller（控制）\n Model（模型）：负责管理应用程序的数据 View（视图）：负责对Model层中的数据进行展示 Controller（控制）：负责用户和应用程序之间的交互  在前端中，model层就是管理数据，实现数据的增删改查等操作，view层负责DOM等操作导致model层的数据改变后，重新渲染页面\nController层负责连接model和view，它接受用户输入（例如鼠标单击或文本输入）并处理用户交互的回调。\n下面通过一个简陋的小的应用程序来了解MVC的具体使用：\n下面四个按钮对上面的数值进行加减乘除操作，再将结果显示在页面上，可以将这个程序分为MVC三个模块：\nModel：负责从localstorage数据获取和将数据更新到localstorage\nconst m = {\r//从localstorage数据获取\rdata: {\rresult: parseInt(localStorage.getItem('data'))\r},\r//数据更新到localstorage\rupdate(data) {\rObject.assign(m.data, data)\reventBus.trigger(\u0026quot;updated\u0026quot;)\rlocalStorage.setItem('data', m.data.result)\r}\r}\r View：负责将model层的数据和HTML渲染到页面\nconst v = {\r//视图的元素\rel: null,\r//包裹元素的容器\rhtml: `\r\u0026lt;div\u0026gt;\r\u0026lt;div class=\u0026quot;result\u0026quot;\u0026gt;\r\u0026lt;span id=\u0026quot;output\u0026quot;\u0026gt;{{n}}\u0026lt;/span\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;button\u0026quot;\u0026gt;\r\u0026lt;button id=\u0026quot;add1\u0026quot;\u0026gt;+1\u0026lt;/button\u0026gt;\r\u0026lt;button id=\u0026quot;min1\u0026quot;\u0026gt;-1\u0026lt;/button\u0026gt;\r\u0026lt;button id=\u0026quot;mul2\u0026quot;\u0026gt;*2\u0026lt;/button\u0026gt;\r\u0026lt;button id=\u0026quot;div2\u0026quot;\u0026gt;/2\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r`,\r//初始化\rinit(container) {\rv.el = $(container) //将容器保存起来\rv.render()\r},\r//渲染+更新\rrender(n) {\rif (v.el.children.length !== 0) v.el.empty();\rv.el = $(v.html.replace('{{n}}', n)).appendTo($(v.el))\r},\r}\r Controller：负责为元素绑定事件，监听用户的点击按钮操作，通过回调函数更新model数据，再让view层渲染到页面\nconst c = {\rinit(container) {\rv.init(container) v.render(m.data.result) //view=render(m.data.result)//视图等于渲染数据\rc.autoBindEvent()\reventBus.on(\u0026quot;updated\u0026quot;, () =\u0026gt; {\rv.render(m.data.result)\r})\r},\rv.el.on(\u0026quot;click\u0026quot;, \u0026quot;#add1\u0026quot;, () =\u0026gt; {\rm.update({\rresult: m.data.result + 1\r})\r})\rv.el.on(\u0026quot;click\u0026quot;, \u0026quot;#min1\u0026quot;, () =\u0026gt; {\rm.update({\rresult: m.data.result - 1\r})\r})\rv.el.on(\u0026quot;click\u0026quot;, \u0026quot;#mul2\u0026quot;, () =\u0026gt; {\rm.update({\rresult: m.data.result * 2\r})\r})\rv.el.on(\u0026quot;click\u0026quot;, \u0026quot;#div2\u0026quot;, () =\u0026gt; {\rm.update({\rresult: m.data.result / 2\r})\r})\r}\r 可以观察到代码中使用了自定义的eventBus来完成Controller层和Model层之间的通信，下面就来聊一聊各模块之间的通信工具——EventBus\nEventBus EventBus 称为事件总线，它的核心思想是发布订阅者模式，我们可以通过调用EventBus 的接口来注册发送事件或接收事件，能达到任意模块之间的通信。\n初始化 如何自定义使用eventBus呢？首先要进行初始化\nimport $ from \u0026quot;jquery\u0026quot;\rconst eventBus = $(window)\r 通过JQuery，把eventBus放在全局\n触发事件 eventBus.trigger(eventName, data)\r 在上个MVC小程序中可以看到 ，M层进行localStorage的数据更新操作后就会触发事件名为updated的事件，EventBus就会传达给监听这个事件的模块，进行通信。\n监听事件 eventBus.on(eventName, () =\u0026gt; {\r//操作\r})\r 在C层监听到事件名为updated的事件发生后就会触发回调函数，通知V层渲染更新M层的新数据。\n取消监听 eventBus.off(eventName, () =\u0026gt; {\r//操作\r})\r 也可以通过off这个API来取消监听\n表驱动编程 表驱动方法编程（Table-Driven Methods）是一种编程模式，简单讲是指用查表的方法获取值。适用场景:消除代码中频繁的if else或switch case的逻辑结构代码,使代码更加直白.\n现在通过利用表驱动方法来优化MVC小程序C层中的绑定事件代码：\nconst c = {\r……\revents: {\r\u0026quot;click #add1\u0026quot;: \u0026quot;add\u0026quot;,\r\u0026quot;click #min1\u0026quot;: \u0026quot;min\u0026quot;,\r\u0026quot;click #mul2\u0026quot;: \u0026quot;mul\u0026quot;,\r\u0026quot;click #div2\u0026quot;: \u0026quot;div\u0026quot;\r},\radd() {\rm.update({\rresult: m.data.result + 1\r})\r},\rmin() {\rm.update({\rresult: m.data.result - 1\r})\r},\rmul() {\rm.update({\rresult: m.data.result * 2\r})\r},\rdiv() {\rm.update({\rresult: m.data.result / 2\r})\r},\rautoBindEvent() {\rfor (let key in c.events) {\rconst space = key.indexOf(\u0026quot; \u0026quot;)\rconst part1 = key.slice(0, space)\rconst part2 = key.slice(space + 1)\rconst value = c[c.events[key]]\rconsole.log(value);\rv.el.on(part1, part2, value);\r}\r},\r 对比之前的代码，表驱动方法编程的优势便体现出来了：\n1、可读性更强，自动绑定事件，一目了然。\n2、更容易修改，要增加新的绑定事件，只要修改数据即可，不需要修改流程。\n3、重用，第一种方法的只有绑定的事件名称、监听元素和回调函数不一样，逻辑都是一样的，产生了很多重复的代码。表驱动方法编程将这种相同的逻辑提取出来，而把容易发生变化的部分提到外面。\n模块化  模块化是将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起\n块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信\n模块化的方法降低代码耦合度，减少重复代码，提高代码重用性，并且在项目结构上更加清晰，便于维护。\n 通过构造一个简单的MVC模式的小应用让我学习了模块的封装。上例MVC小程序中的我们已经将程序划分为三个对象并完成了模块的封装，只需把C层对象导出，其他页面引入C对象，通过我们在暴露的init方法初始化传给C对象一个容器，就可以添加使用这个计算小程序，而不需要知道其内部的具体实现。\n目前最常使用的两种模块化规范就是 ESM (ES Module)和CommonJS\nESM (ES Module) 语法规则\nimport defaultExport from \u0026quot;module-name\u0026quot;;\rimport * as name from \u0026quot;module-name\u0026quot;;\rimport { export1 , export2 } from \u0026quot;module-name\u0026quot;;\rimport { export1 , export2 as alias2 , [...] } from \u0026quot;module-name\u0026quot;;\rimport defaultExport, { export1 [ , [...] ] } from \u0026quot;module-name\u0026quot;;\r// 等 ...\rexport let name1, name2, …, nameN; // also var, const\rexport { name1, name2, …, nameN };\rexport default function (…) { … } // also class, function*\rexport { name1, name2, …, nameN } from …;\r// 等 ...\r CommonJS 语法规则\n'use strict';\rvar lodash = require('lodash');\rconst result = lodash.every(\r[true, 1, null, 'yes'],\rBoolean,\r);\rmodule.exports = result;\r 相比 esm 主要差别在语法上：\n esm  import a from 'b' export default c   cjs  const a = require('b') module.exports = c   ","date":"2020-12-25","permalink":"https://heeeyueee.github.io/post/%E6%B5%85%E6%9E%90mvc/","tags":["MVC"],"title":"浅析前端MVC"},{"content":" webpack5\n 记录进行webpack5配置时踩的坑\n安装webpack-dev-server 安装过程：参考官方文档 使用webpack-dev-server\n安装和配置过程都很顺利，但按照官方的文档配置脚本命令时出错：\n 官方:\n \r\u0026quot;start\u0026quot;: \u0026quot;webpack-dev-server --open\u0026quot;\r 更改为：\nstart\u0026quot;: \u0026quot;webpack serve\u0026quot;\r 图片  根据之前webpack4的教程 安装配置url-loader和file-loader就可以引入图片，但是我都尝试了发现图片死活出不来\n 查看webpack5的官方的文档，发现是更新啦！指路：资源模块\nwebpack5在资源模块类型(asset module type)添加了 4 种新的模块类型，这样我们使用图片这些静态资源时就不在需要安装loader了来加载了，具体如下:\n asset/resource 发送一个单独的文件并导出 URL。之前通过使用 file-loader 实现。 asset/inline 导出一个资源的 data URI。之前通过使用 url-loader 实现。 asset/source 导出资源的源代码。之前通过使用 raw-loader 实现。 asset 在导出一个 data URI 和发送一个单独的文件之间自动选择。之前通过使用 url-loader，并且配置资源体积限制实现。  所有，无需安装loader，只需要配置一下，build之后，在dist文件夹中就可以看见图片啦：\nmodule.exports = {\r/* ... */\rmodule: {\rrules: [\r// Images\r{\rtest: /\\.(?:ico|gif|png|jpg|jpeg)$/i,\rtype: 'asset/resource',\r},\r],\r},\r}\r","date":"2020-12-24","permalink":"https://heeeyueee.github.io/post/webpack5%E9%85%8D%E7%BD%AE%E8%B8%A9%E5%9D%91/","tags":["webpack"],"title":"webpack5使用出错记录"},{"content":" 复习CSS\n 层叠 CSS是由Cascading Style Sheets三个词的首字母缩写，翻译为层叠样式表，其中最重要的概念就是层叠。\nCSS层叠是一种算法，浏览器通过它来决定将哪些CSS样式规则应用到一个元素上\n当多个相互冲突的CSS声明应用于同一个元素时，CSS层叠算法会根据一定的机制，从最高权重到最低权重的顺序列出：\n 来源（行内\u0026gt;内联\u0026gt;链接）和重要性(!important) 选择器权重 出现的顺序 初始和继承属性（默认值）  优先级   优先级就是分配给指定的 CSS 声明的一个权重，浏览器器会将最高优先级的样式应用到元素上。\n  当多个 CSS 声明的优先级相等时（均为最高），其中最后的那个声明将会被应用到元素上。\n  important\u0026gt;内联 \u0026gt;ID\u0026gt;类 \u0026gt;标签 |伪类|属性选择 \u0026gt;伪对象 \u0026gt;继承 \u0026gt;通配符\n  ID 选择器：如 #id{}\r类选择器：如 .class{}\r属性选择器：如 a[href=\u0026quot;baidu.com\u0026quot;]{}\r伪类选择器：如 :hover{}\r标签选择器：如 span{}\r伪元素选择器：如 ::before{}\r通配符选择器：如 *{}\r 关于优先级的判定：有一套计算规则参考深入理解CSS选择器优先级\n继承 HTML是层级结构的， 一些设置在父元素上的css属性是可以被子元素继承的，有些则不能。\n可继承的属性    种类 属性     字体属性 font、font-family、font-weight、font-size、font-style   文本属性 text-indent、text-align、text-shadow、line-height、color、direction、word-spacing、letter-spacing、text-transform   元素可见属性 visibility   表格布局属性 caption-side、border-collapse、border-spacing、empty-cells、table-layout   列表布局属性 list-style-type、list-style-image、list-style-position、list-style   生成内容属性 quotes   光标属性 cursor    不可继承的属性    种类 属性     布局属性 display   文本属性 vertical-align、text-decoration、text-shadow、white-space   盒模型的属性 width、height、margin 、border、padding   背景属性 background、background-color、background-image   定位属性 float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index    所有元素可以继承的属性 元素可见性：visibility\n光标属性：cursor\n内联元素可以继承的属性 字体系列属性\n除text-indent、text-align之外的文本系列属性\n块级元素可以继承的属性 text-indent、text-align\n","date":"2020-12-17","permalink":"https://heeeyueee.github.io/post/css%E7%9A%84%E5%B1%82%E5%8F%A0%E5%92%8C%E7%BB%A7%E6%89%BF/","tags":["CSS"],"title":"CSS的层叠和继承"},{"content":" Set与Map\n  前言：小白本人最近在leetcode上做题，发现经常会用到hash表这种数据结构，并且都是用ES6中的新数据结构Map来实现的，\n所以连带着Set来一起总结一下\n Set ES6 提供了新的数据结构 Set。它类似于数组，允许存储任何类型的值，无论是原始值或者是对象引用，但是成员的值都是唯一的，没有重复的值。\n特征  只能保存值没有键名 严格类型检测，如字符串数字不等于数值型数字 值是唯一的 遍历顺序是添加的顺序，方便保存回调函数  基本使用 创建 要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set：\nlet s1 = new Set(); // 空Set\rlet s2 = new Set([1, 2, 3]); // 含1, 2, 3\r 重复元素在Set中自动被过滤：\nlet s = new Set([1, 2, 3, 3, '3']);\rs; // Set {1, 2, 3, \u0026quot;3\u0026quot;}\r 添加元素 使用 add(key)方法添加元素，不允许添加重复的值\ns2.add(4)// Set {1, 2, 3, 4}\rS2.add(1)// Set {1, 2, 3, 4}\r 获取元素总量 size属性表示Set中的元素数量\nconsole.log(s2.size); //4\r 元素检测 has()方法来检测Set中是否含该元素\nconsole.log(s2.has(1));//true\r 删除元素 使用 delete 方法删除单个元素，返回值为boolean类型\ns2.delete(\u0026quot;1\u0026quot;) //true\r 使用 clear 删除所有元素\ns1.clear();\r 数组转换 可以使用点语法 或 Array.form 静态方法将Set类型转为数组，这样就可以使用数组原型中的函数和属性了\nconsole.log([...s2]); // {1, 2, 3, 4}--\u0026gt;[1,2,3,4]\rconsole.log(Array.from(s2)); //{1, 2, 3, 4}--\u0026gt;[1,2,3,4]\r 去除重复 去除字符串重复\n[...new Set(\u0026quot;dooog\u0026quot;)].join(\u0026quot;\u0026quot;);//dog\r 去除数组重复\nconst arr = [1, 2, 3, 5, 2, 3];\rconsole.log(...new Set(arr)); // 1,2,4,5\r 遍历数据  keys() values() entries() forEach() forof  因为set类型只有值所以 keys与values 方法结果一致，entries()遍历获得的key和value也是一样的\nconst set=new Set([1, 2, 3])\rfor (let item of set.keys()) {\rconsole.log(item)\r}\r//1 2 3\rfor (let item of set.entries()) {\rconsole.log(item)\r}\r// [1, 1] [2, 2] [3, 3]\rset.forEach((item,key) =\u0026gt; console.log(item,key));\r// 1 1 2 2 3 3\r Map JavaScript的默认对象表示方式{}，表示一组键值对。但是JavaScript的对象有个问题，就是键必须是字符串，但实际上我们需要key是其他数据类型。为了解决这个问题，最新的ES6规范引入了新的数据类型Map。\n特征  具有极快的查找速度 函数、对象、基本类型都可以作为键或值  基本使用 创建 初始化Map需要一个二维数组，或者直接初始化一个空Map。\nlet m = new Map([\r['son', 'moji'],\r['father', 'blend']\r]);\r 添加元素 使用set 方法添加元素，支持链式操作\nlet obj={name:\u0026quot;zhangsan\u0026quot;}\rmap.set(obj, \u0026quot;zhangsan\u0026quot;).set(\u0026quot;uncle\u0026quot;, \u0026quot;lisi\u0026quot;);\r 获取数量 size属性表示Map中的元素数量\nconsole.log(map.size);  元素检测 has()方法来检测Map中是否含该键值对\nconsole.log(map.has(obj1));\r 读取元素 get(key)方法获取key对应的值\nconsole.log(map.get(obj));//zhangsan\r 删除元素 使用 delete(key) 方法删除单个元素\nmap.delete(obj);\r 使用clear方法清除Map所有元素\nmap.clear()\r 数组转换 可以使用展开语法 或 Array.form 静态方法将Map类型转为数组，这样就可以使用数组原型中的函数和属性了\nlet map = new Map([[\u0026quot;son\u0026quot;, \u0026quot;moji\u0026quot;], [\u0026quot;father\u0026quot;, \u0026quot;blend\u0026quot;]]);\rlet newArr = [...map].filter(function(item) {\rreturn item[1].includes(\u0026quot;moji\u0026quot;);\r});//[\u0026quot;son\u0026quot;, \u0026quot;moji\u0026quot;]\r 遍历数据  keys() values() entries() forEach() forof  for (const value of map.values()) {\rconsole.log(value);\r}\rfor (const item of map.entries()) {\rconsole.log(value);\r}\rfor (const [key, value] of map) {\rconsole.log(`${key}=\u0026gt;${value}`);\r}\rmap.forEach((value, key) =\u0026gt; {\rconsole.log(`${key}=\u0026gt;${value}`);\r})\r","date":"2020-12-17","permalink":"https://heeeyueee.github.io/post/es6%E4%B8%AD%E7%9A%84set%E4%B8%8Emap/","tags":["JavaScript"],"title":"ES6中的Set与Map"},{"content":" 總結一些關於CSS的小技能 不斷更新\n 画三角形 使用纯CSS来画三角形需要用到border属性，本示例中的盒模型都是使用W3C盒模型 box-sizing: border-box;(两种盒模型的效果一致)\n\u0026lt;div class=\u0026quot;square\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;top\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\r.square{ width: 0;\rheight: 0;\rborder-style: solid;\rborder-width: 50px;\rborder-color: red black blue yellow;\r}\r//箭头向下的三角形\r//写法一\r.top{\rwidth: 0;\rheight: 0;\rborder: 50px solid transparent;\rborder-top: 50px solid red;\r}\r//写法二\r.top { width: 0; height: 0; border: 50px solid red;\rborder-color:red transparent transparent transparent;\r}\r 其实画三角形就是利用了border的形状，在.square中把盒子的宽度和高度设置为0，只给border设置宽度，就可以得到被对角线划分为四个三角形的正方形。通过给其余的三角形对应的border加上transparent属性就可以得到我们想要的三角形，两种写法都可，第一种代码更少用它用它。\n画圆 半圆 椭圆 要花圆的画基本离不开border-radius这个属性，先来简单学习一下这个属性（这玩意深究起来贼复杂）\n👉想要深入学习指路博客:图解CSS：border-radius\nborder-radius border-radius主要作用是用来给元素绘制圆角效果。它和border属性类似，是border-top-left-radius、border-top-right-radius、border-bottom-left-radius和border-bottom-right-radius四个属性的简写形式。\n注意哈！和border的简写不同，不是顺时针方向\n一个值 元素所有的角都会用这个值作为圆角半径\n.demo { border-radius: 50px; }\r 两个值 .element { border-radius: 50px 80px; }\r 第一个值表示左上角和右下角圆角半径，第二个值表示右上角和左下角圆角半径。\ny轴 z轴 其实border-radius可以取分x轴和y轴取值，而且每个轴取值个数可以是{1, 4}（一到四个）,x和y轴之间由/来分隔\n\u0026lt;length-percentage\u0026gt;{1,4} [ / \u0026lt;length-percentage\u0026gt;{1,4} ]?\r .demo {\rheight: 100px;\rwidth: 200px;\rborder-radius: 160px / 100px;\r}\r 画椭圆 #oval { width: 200px; height: 100px; border-radius: 100px / 50px; }\r 使用了border-radius的X/Y两轴取值，制作出一种变形的圆角，在配合宽度和高度值，就制作了类似椭圆形的一个效果。\n用的时候就一个字，试\n画半圆 #semicircle{ width: 100px; height: 50px; background: red; border-radius: 100px 100px 0 0; }\r 配合元素的高度，宽度以及圆角的方位，制作出半圆形效果。\n画心形 指路我画的动态心形👉心形图\n里面用了三个div 其实可以只用一个div加上：before和：after伪元素来画，值得改进\n","date":"2020-12-17","permalink":"https://heeeyueee.github.io/post/css%E5%B0%8F%E6%8A%80%E8%83%BD/","tags":["CSS"],"title":"Pure CSS教你画图"},{"content":" 同源策略、CORS、JSONP~\n 跨域问题的产生 跨域是指从一个源的网页去请求另一个源的网页的资源。但是一般情况下不能这么做，它是由浏览器的同源策略造成的，是浏览器对JavaScript施加的安全限制。\n同源策略 同源策略（SOP）是Web浏览器强制执行的一种安全策略，用于控制对网站和Web应用程序之间数据的访问。 没有SOP，任何网页都将能够访问其他页面的DOM。 这将使它可以从另一个网页访问潜在的敏感数据，以及在未经用户同意的情况下在其他网页上执行操作。\n简单来说，如果JS 运行在源A 里，那么就只能获取源A 的数据不能获取源B 的数据， 即不允许跨域。\n源是什么？\n源= 协议+ 域名+ 端口号\r 如果两个url 的协议、域名、端囗号完全一致， 那么这两个url 就是同源的 举例：https://baidu.com 、https://www.baidu.com 不同源，完全一致才算同源\n常用的两种解决方式 但是现实中确要跨域共享内容,下面总结最常用的两种方式\nCORS CORS是一个W3C标准，全称是\u0026quot;跨域资源共享\u0026quot;（Cross-origin resource sharing)。\nCORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。\n实现CORS通信的关键是服务器，需要服务器实现了CORS接口，最关键的步骤就是在响应头中配置Access-ControI-AIIow-Origin属性\nAccess-ControI-AIIow-Origin:允许跨域访问的url\r 👉关于CORS详细的解读参考以下文章：\n跨源资源共享（CORS）\n跨域资源共享 CORS 详解\nJSONP JSONP是服务器与客户端跨源通信的常用方法,简单适用。\n💁🏼‍♀️插一嘴：了解JSONP之前，先讨论一下在HTML文件中使用script标签引用其他网站JS文件的问题。\n 有时候为了方便我们会直接通过script标签在HTML中引用https://www.bootcdn.cn/等网站上的JS库，我们能成功的引用JS并成功执行相关操作，这算不算跨域呢？答案是这不是跨域，这种做法不受同源政策限制，因为只是拿来用而已，也并没有拿到JS文件中的具体内容。\n 因为引用JS文件不受同源政策限制，那就可以通过引入JS文件来请求服务端的数据，所以JSONP的基本思想便是网页通过添加一个\u0026lt;script\u0026gt;元素，向服务器请求JSON数据，服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。\n下面来简单演示一下客户端的操作：\n客户端\nfunction jsonp(url) {\rreturn new Promise((resolve, reject) =\u0026gt; {\rconst random = \u0026quot;JSONPCallbackName\u0026quot; + Math.random();\rwindow[random] = data =\u0026gt; {\rresolve(data);//跨网站回调，等到引入JS文件拿到数据后执行\r};\rconst script = document.createElement(\u0026quot;script\u0026quot;);\rscript.src = `${url}?callback=${random}`;\rscript.onload = () =\u0026gt; {\rscript.remove();\r};\rscript.onerror = () =\u0026gt; {\rreject();\r};\rdocument.body.appendChild(script);\r});\r}\rjsonp(\u0026quot;http://example.com:8888/example.js\u0026quot;).then(data =\u0026gt; {\rconsole.log(data);\r});\r 上面代码采用promise对JSONP进行了封装，详细步骤就是通过动态添加\u0026lt;script\u0026gt;元素来引入服务器端的JS文件，向服务器example.com发出请求，JS文件里面会执行一个回调函数 window[random]，回调里面就有我们最终想要得到的数据（如果是请求JSON数据，这个回调函数就像有外边距的JSON数据，所以叫JSONP，其实它是可以携带其他类型数据的，比如HTML等）。\n💁🏼‍♀️注意，回调的名字是可以是随机的，请求的查询字符串有一个callback参数，通过这个参数来指定回调函数的名字告知服务端，这对于JSONP是必需的。最后，得到数据后可用删掉script标签，以免造成HTML页面混乱。\n引入的example.js文件\nwindow[random](JSON数据)\r 由于\u0026lt;script\u0026gt;元素请求的JS文件可以直接作为代码运行。这时，只要浏览器定义了window[random]函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。\n优点  兼容老版本IE 可以跨域访问数据  缺点  因为是script标签来请求引用的JS，所以无法像方法一中ajax请求那样可以判断整个过程的状态，并且不能拿到status和header，只能知道失败或成功，只有onload和onerror两个回调函数可用。 因为是script标签所以只能发送get请求，不支持post  两种方法的比较   JSONP只支持GET请求，CORS支持所有类型的HTTP请求。\n  JSONP的优势在于支持老式浏览器（IE 6，7，8，9），以及可以向不支持CORS的网站请求数据。\n  参考 浏览器同源政策及其规避方法\n","date":"2020-12-15","permalink":"https://heeeyueee.github.io/post/js%E8%B7%A8%E5%9F%9F%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","tags":["JavaScript"],"title":"JS跨域及解决方案"},{"content":" 学习异步与Promise\n 同步与异步 同步（Synchronous） 同步可以直接拿到结果\n简单的例子来说，同步就是在学校食堂吃饭，必须要排队打饭，在打到饭之前都不能离开去做其他事情。\n用计算机的语言来解释就是同步就是整个处理过程顺序执行，当各个过程都执行完毕，并返回结果。是一种线性执行的方式，执行的流程不能跨越。\n异步（Asynchronous） 异步不能直接拿到结果，需要后续通过轮询或者回调的方法来得到结果\n简单的例子来说，异步就是在网红饭店改善生活时，可以在在手机上取号后，就去逛街买奶茶干其他的事情，当手机上通知到你时再去就餐。\n用计算机的语言来解释只是发送了调用的指令，调用者无需等待被调用的方法完全执行完毕；而是继续执行下面的流程。是一种并行处理的方式。\nJS是单线程的  学习Java时，Java中可以通过开启多线程来完成异步操作，但是JS是单线程的是怎样执行异步任务的呢？\n JS是单线程的，是指在浏览器的JS引擎中负责解释和执行JavaScript代码的线程只有一个，所以我们所写的JS代码在JS引擎中都是排队（同步）执行的。但很多时候关于I/O设备的操作要比闪电般的JS引擎慢很多，比如鼠标键盘的操作、网络请求……JS引擎中遇到这样的任务就很容易导致后续其他任务阻塞的问题，所以需要异步执行JS代码中的这些任务，咋异步呢？\n多线程的浏览器就来帮忙啦，直接甩出三个大招（API),分别是 DOM Binding(DOM绑定)、network(网络请求)、timer(定时器)模块。\n如果JS代码中的任务是属于这三个模块，浏览器就会判断它为异步任务，然后JS引擎中一遇到异步任务，浏览器就会把异步任务相关回调添加到任务队列中（异步任务必须要有回调函数），等待主线程的任务执行完毕，再执行任务队列中的任务。\n这种运行机制称为Event Loop（事件循环）\n（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。\n（2）主线程之外，还存在一个\u0026quot;任务队列\u0026quot;（task queue）。只要异步任务有了运行结果，就在\u0026quot;任务队列\u0026quot;之中放置一个事件。\n（3）一旦\u0026quot;执行栈\u0026quot;中的所有同步任务执行完毕，系统就会读取\u0026quot;任务队列\u0026quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。\n（4）主线程不断重复上面的第三步。\nPromise 上面介绍了JS中需要异步，Promise就是ES6中异步编程的一种解决方案\n为什么需要Promise？ 以往我都使用jQuery封装的Ajax来发送网络请求，当网络请求十分复杂时就会出现回调地狱\n上图中回调得到的数据很容易混淆，且代码就十分难看且不容易维护，所以我们需要更优雅的方式来进行异步操作\nPromise的使用 第一步\n创建一个promise对象、可以使用new来调用Promise的构造器来进行实例化\nreturn new Promise((resolve,reject)=\u0026gt;{\r// 异步处理\r// 处理结束后、调用resolve 或 reject\r})\r   任务成功时调用resolve(成功)  任务失败时调用reject(失败)\n  resolve 和 reject 都只接受一个参数\n  第二步\n第一步构造出来的promise对象，含有一个 .then() 函数属性使用promise.then() 实例方法，设置其值在 resolve(成功) / reject(失败)时调用的回调函数\npromise.then(onFulfilled, onRejected)\r   resolve(成功)时\nonFulfilled 会被调用\n  reject(失败)时\nonRejected 会被调用\n  举例\n使用promise来发送网络请求\nfunction getURL(URL) {\rreturn new Promise(function (resolve, reject) {\rvar req = new XMLHttpRequest();\rreq.open('GET', URL, true);\rreq.onload = function () {\rif (req.status === 200) {\rresolve(req.responseText);\r} else {\rreject(req.statusText));\r}\r};\rreq.onerror = function () {\rreject(req.statusText));\r};\rreq.send();\r});\r}\rvar URL = \u0026quot;http://xxx\u0026quot;;\rgetURL(URL).then(function onFulfilled(value){\rconsole.log(value);\r},function onRejected(error){\rconsole.log(error);\r});\r Promise还有更高级的用法，链式调用等等，以后在进行总结~\n参考 JavaScript 运行机制详解：再谈Event Loop\n并发模型与事件循环MDN\nJavaScript Promise迷你书（中文版）\n","date":"2020-12-14","permalink":"https://heeeyueee.github.io/post/%E5%BC%82%E6%AD%A5%E4%B8%8Epromise/","tags":["JavaScript"],"title":"异步与Promise"},{"content":"Ajax的原理  Asynchronous JavaScript + XML（异步JavaScript和XML）, 其本身不是一种新技术，而是一个在 2005年被Jesse James Garrett提出的新术语，用来描述一种使用现有技术集合的‘新’方法，包括: HTML 或 XHTML, CSS, JavaScript, DOM, XML, XSLT, 以及最重要的 XMLHttpRequest。当使用结合了这些技术的AJAX模型以后， 网页应用能够快速地将增量更新呈现在用户界面上，而不需要重载（刷新）整个页面。这使得程序能够更快地回应用户的操作。\n 上面是MDN中对Ajax的介绍，学习Ajax之后，我对Ajax原理的理解就是，Ajax是JS操控浏览器异步向服务器发送请求的技术，其中最核心的依赖是浏览器提供的XMLHttpRequest API，XHR 是一种用于在 Web 浏览器和 Web 服务器间传输数据消息的 JavaScript API。它支持浏览器使用 HTTP POST（将数据传到服务器）或 GET 请求（从后台服务器访问数据）。\nAjax的使用 在Ajax的原理中提到了浏览器提供的XMLHttpRequest API，它是Ajax交互的核心，学习Ajax就必须掌握XMLHttpRequest的使用。\n💁🏼‍♀️**插一嘴：**XMLHttpRequest是IE浏览器发明的，XMLHttpRequest是浏览器在window上创建的一个全局函数，可以用这个构造函数\n来构造出一个对象，JS通过这个对象来发送请求，处理响应数据。\nXMLHttpRequest API 和特性 XHR 交互由两部分组成：请求和响应。\n先通过一个最简单的例子来展示发送请求和接收响应的全过程：\ngetCSS.onclick = () =\u0026gt; {\rlet request = new XMLHttpRequest()//第一步\rrequest.open('get', '/style.css');//第二步\rrequest.send()\rrequest.onreadystatechange = () =\u0026gt; {//第三步\rif (request.readyState === 4) {\rif (request.status \u0026gt;= 200 \u0026amp;\u0026amp; request.status \u0026lt; 300) {\rconsole.log('success');\r//使用ajax请求css\rconst style = document.createElement('style')\rstyle.innerHTML = request.response\rdocument.head.appendChild(style)\r} else {\rconsole.log('fail');\r}\r}\r}\r}\r 可以分为三个过程：\n  使用XMLHttpRequest构造函数创建Ajax核心对象XMLHttpRequest\nlet request = new XMLHttpRequest()\r   向服务器发送请求\n请求端有 4 种方法：\n open()发起服务器连接。可以带参数：  method将要使用的 HTTP 方法（可以是 POST 或者 GET） url请求的 URL async可选布尔参数，表明请求是否异步（该参数的默认值为 Ture） user一个可选用户名，供认证使用 password一个可选密码，供认证使用   setRequestHeader() 设置请求报头，带有两个参数：报头及其相关值 send() 发送请求。该方法带有一个可选参数，包含 POST 请求的正文 abort() 中止请求  GET和POST请求数据区别\n  使用Get请求时,参数在URL中显示,而使用Post方式,则放在send里面\n  使用Get请求发送数据量小,Post请求发送数据量大\n  使用Get请求安全性低，会被缓存，而Post请求反之 关于第一点区别，详情见下面两张图（来源参考博客）：\n    服务器响应处理\n实例化完成后，根据请求和响应的时机XMLHttpRequest 对象有会有不同的状态，readyState属性表示对象的状态，当readyState属性发生改变时就会触发（调用）XMLHttpRequest.onreadystatechange回调函数，我们可以根据对象的状态在回调函数中处理响应数据。\n👉readyState总共有5个状态值，分别为0~4，每个值代表了不同的含义\n 0: UNSENT表示对象已创建 1: OPENED表示 open() 方法已成功调用 2: HEADERS_RECEIVED表示来自请求的报头已收到， 已经调用send()方法，但尚未接收到响应； 3: LOADING表示响应报头已下载 4: DONE表示请求完成，但是并没有指出请求是否成功或返回预期值（查询响应和标准 HTTP 报头来估量请求的健康状况）  响应有关的属性和方法：\n status请求的标准 HTTP 状态（例如，成功请求将返回 200）可以详见另外一篇文章👉HTTP请求与HTTP响应https://juejin.cn/post/6898568274758336519 statusText包括 Web 服务器返回的完整响应字符串，其中包括响应文本（例如，304 Not Modified） getResponseHeader()返回特定报头内容；请求报头名称是其惟一参数 getAllResponseHeaders()返回所有响应报头的文本 responseText响应文本的字符串表示 responseXML响应文本的 XML 表示，接收数据是XML格式时    JSON的使用 尽管X在Ajax中代表XML, 但由于JSON的许多优势，比如更加轻量以及作为Javascript的一部分，目前JSON的使用比XML更加普遍。JSON和XML都被用于在Ajax模型中打包信息。\nJSON只是一种标记语言，和HTML、XML一样都是用来展示数据。\n关于JSON的使用和介绍查看下面的文章，学会火车轨道图就会使用JSON了~\n👉介绍JSON\nJSON支持的数据类型   string- 只支持双引号， 不支持单引号和无引号\n  number- 支持科学记数法\n  bool - true 和false\n  null - 没有undefined\n  object\n  array\n注意：跟JS 的七种数据类型区别开来不支持函数， 不支持变量（ 所以也不支持引用）\n  window.JSON 是浏览器提供的全局对象，有两个阔以调用的方法\nJSON.parse() JSON 字符串= \u0026gt; JS 数据\n 将符合JSON 语法的字符串转换成JS 对应类型的数据，由于JSON 只有六种类型， 所以转成的数据也只有6 种 如果不符合JSON 语法， 则直接抛出一个Error 对象  JSON.stringify() JS 数据= \u0026gt; JSON 字符串\n 是JSON.parse 的逆运算,由于JS 的数据类型比JSON 多， 所以不一定能成功，如果失败， 就抛出一个Error 对象(比如函数)    💁🏼‍♀️后话：曾经使用过原生的Ajax和经过jQuery封装过的ajax来发送请求，可是两种方法都已经过时，现在是解决异步问题已经Promise的天下了，下一篇文章会学习使用Promise\n","date":"2020-12-13","permalink":"https://heeeyueee.github.io/post/ajax%E7%9A%84%E5%8E%9F%E7%90%86/","tags":["JS"],"title":"Ajax的原理与使用"},{"content":" DOM事件相关\n DOM 事件   事件是什么？\n在Web应用程序中，事件就是将应用程序内的发生的动作或者发生的事情告知浏览器，浏览器给出响应。\n  事件和JavaScript有什么关系？\n事件是客户端（浏览器）的一种处理机制，事件机制与JavaScript并不存在存在直接联系，联系的建立是依靠客户端来实现的，事件机制本身并不是JavaScript语言的内容。\n简单来说，DOM事件并不是JavaScript的功能，而是浏览器支持的功能，我们只是使用JavaScript来完成事件的监听和对事件做出响应。\n  事件绑定 HTML内联绑定事件 HTML中直接绑定DOM，就是在HTML的元素中使用\u0026lt;event\u0026gt;属性来绑定事件，比如onclick这样的on(type)属性，其中type指的就是DOM的事件（比如click），它可以给这个DOM元素绑定一个类型的事件。\n\u0026lt;button onclick=\u0026quot;show();\u0026quot;\u0026gt;Click Me\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; function show() { console.log('Show Me!')\r} \u0026lt;/script\u0026gt;\r JavaScript中绑定DOM事件 在JavaScript中绑定DOM事件有两种方法：\n  element.on(type) = listener\nlet btn = document.querySelector('button') btn.onclick = function () { console.log(\u0026quot;Show Me!\u0026quot;); //被覆盖\r};\rbtn.onclick = function () { console.log(\u0026quot;Show Me again!\u0026quot;); //最终绑定\r};\r 按照DOM事件级别分类，上面的方法是DOM0级事件，就是将一个函数赋值给一个事件处理属性,优点是降低HTML和JS的耦合，并且处理函数可以接收浏览器创建的事件对象event作为参数，缺点在于无法同时给同一个DOM元素绑定多个处理函数，执行上面两次绑定时，下面的函数就会覆盖上面的。\n  element.addEventListener(type, listener, useCapture)\n参数：\nelement：表示要监听事件的目标对象\ntype：表示事件类型的字符串，比如click、change、touchstart等\nlistener：当指定的事件类型发生时被对知到的一个对象，一般是是一个函数。\nuseCapture：设置事件的捕获或者冒泡，它有两个值，其中true表示事件捕获，为false是事件冒泡，默认值为false\n\u0026lt;button\u0026gt;Click Me!\u0026lt;/button\u0026gt;\r\u0026lt;script\u0026gt; function show (e) { console.log(\u0026quot;Show Me!\u0026quot;) console.log(e)\r} let btn = document.querySelector('button') btn.addEventListener('click', show, false)\r\u0026lt;/script\u0026gt;\r 按照DOM事件级别分类，上面的方法是DOM2级事件，优点是可以给同一个DOM元素绑定多个处理函数，并且遵循“先绑定先触发”的原则，处理函数可以接收浏览器创建的事件对象event作为参数。\n  事件对象 当事件发生时，浏览器会创建一个事件对象，将详细信息放入这个对象当中，下图是把代码中点击事件对象event打印出来的结果。\nEvent对象在event第一次触发的时候被创建出来，并且一直伴随着事件在DOM结构中流转的整个生命周期（当事件结束后，可以认定为对象也消失了，所有当想一直使用event对象的数据时，可以赋值给其他对象来保留数据）。event对象会被作为第一个参数传递给事件监听的回调函数。我们可以通过这个event对象来获取到大量当前事件相关的信息，下面挑选几个重要的参数：\n  type (String)：事件的名称\n  target (node)：事件起源的DOM节点，可以理解为用户操作的元素\n  currentTarget?(node)：当前回调函数被触发的DOM节点，可以理解为用户监听的元素\n👉详细信息MDN文档\n  DOM事件流 \u0026lt;div onclick=\u0026quot;parent\u0026quot;\u0026gt;\r\u0026lt;div onclick=\u0026quot;child\u0026quot;\u0026gt;click\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;  上面的代码中，在子元素和父元素上都注册了点击事件，当点击文字时，是先触发父元素上的事件函数，还是子元素上的事件函数呢，这就需要一种约定去规范事件的执行顺序，就是事件执行的流程。 浏览器在发展的过程中出现了两种不同的规范：\n IE9以下的IE浏览器使用的是事件冒泡，由内向外找监听函数。 Netscapte采用的是事件捕获，由外向内找监听函数。 而W3C制定的Web标准中，是同时采用了两种方案，事件捕获和事件冒泡都可以。  W3C事件模型 W3C规范中定义了三个事件传播阶段，依次是捕获阶段、目标阶段和冒泡阶段。\n  捕获阶段（Capture Phase）：事件从window对象自上而下向目标节点传播的阶段；\n  目标阶段（Target Phase）：真正的目标节点正在处理事件的阶段；如果一个事件对象类型被标志为不能冒泡，那么对应的事件对象在到达此阶段时就会终止传播。\n  冒泡阶段（Bubbling Phase）：事件从目标节点自下而上向window对象传播的阶段。\n给DOM元素绑定事件都会经历三个传播阶段，当事件发生时，始终从根开始，沿着路径直到达到目标，然后再重新追溯根源，然后回到根。而其中启动事件的部分和事件从根向下寻找目标称为事件捕获阶段，从目标回到根的阶段为冒泡阶段。\n   我们可以通过使用事件绑定API指定该父辈事件监听函数是捕获阶段还是冒泡阶段被触发：\n   IE的API：element.attachEvent('oncIick', (n)  //指定为冒泡阶段被触发\n  Netscapte的API：element.addEventListener('cIick',fn) / /指定为捕获阶段被触发\n  W3C的API：element.addEventListener('cIick',fn,bool) \nbool没有值或值为falsy——冒泡\nbool值为ture——捕获\n  事件中断 现实中，很多时候我们并不希望目标元素的事件结束之后还去追溯其根源（冒泡）。在JavaScript中可以在事件对象上使用stopPropagation方法来阻止目标元素的冒泡事件，但是会不阻止默认行为。\nfunction show (e) { e.stopPropagation();\r}\r 取消默认事件  浏览器默认事件  许多事件会自动触发浏览器执行某些行为。\n例如：点击一个链接 会触发导航（navigation）到该 URL，点击表单的提交按钮 会触发提交到服务器的行为。\n 取消方法   使用 event 对象的 event.preventDefault() 方法  \u0026lt;a href=\u0026quot;/\u0026quot; onclick=\u0026quot;event.preventDefault()\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt;\r return false  \u0026lt;a href=\u0026quot;/\u0026quot; onclick=\u0026quot;return false\u0026quot;\u0026gt;Click here\u0026lt;/a\u0026gt;\r 事件委托 由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的委托（delegation）。\n适用场景 场景一:给N个同级元素添加点击事件\n解决：使用事件委托，在父元素parent上设置监听函数\n\u0026lt;div id=\u0026quot;parent\u0026quot;\u0026gt;\r\u0026lt;button data-id=\u0026quot;1\u0026quot;\u0026gt;1\u0026lt;/button\u0026gt;\r\u0026lt;button\u0026gt;2\u0026lt;/button\u0026gt;\r\u0026lt;button\u0026gt;3\u0026lt;/button\u0026gt;\r\u0026lt;button\u0026gt;4\u0026lt;/button\u0026gt;\r\u0026lt;button\u0026gt;5\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rparent.addEventListener('click',(e)=\u0026gt;{\rconst t=e.target\rif(t.target.toLowerCase()=='button'){\rconsole.log(\u0026quot;button被点击了\u0026quot;);\rconsole.log('button的data-id是'+t.dataset.id);\r}\r})\r\u0026lt;/script\u0026gt;\r 场景二：监听目前还不存在的元素的点击事件\n解决：先监听父元素， 等点击的时候看看是不是我想要监听的元素即可\n\u0026lt;div id=\u0026quot;parent\u0026quot;\u0026gt; \u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rsetTimeout(()=\u0026gt;{\rconst button=document.createElement('button')\rbutton.textContent='button'\rparent.appendChild(button)\r},1000)\rparent.addEventListener('click',(e)=\u0026gt;{\rconst t=e.target\rif(t.target.toLowerCase()=='button'){\rconsole.log(\u0026quot;button被点击了\u0026quot;);\r}\r})\r\u0026lt;/script\u0026gt;\r 优点   减少内存消耗，提高性能\n参考场景一，不用单独给每个按钮绑定监听函数，我们只需要给父容器绑定函数即可，这样不管点击的是哪一个后代元素，都会根据冒泡传播的传递机制，把容器的click行为触发，然后把对应的方法执行，根据事件源（target），我们可以知道点击的是哪个子元素，从而完成不同的事。\n  动态绑定事件\n  ​ 参考场景二，那么在元素动态发生变化时，就需要给新增的元素绑定事件，给即将删去的元素解绑事件，如果用事件代理就会省去很 多这样麻烦。\n参考 事件绑定的姿势\n深入理解DOM事件机制\n","date":"2020-12-08","permalink":"https://heeeyueee.github.io/post/dom%E4%BA%8B%E4%BB%B6/","tags":["JavaScript","DOM"],"title":"详解DOM事件机制"},{"content":" 总结常用的api ，学习jQuery的设计模式\n   前言：之前参与项目时，连Javascript都没学明白的我，靠着jQuery也完成了任务，决定走前端这条道路后，我重头开始学JavaScript，DOM…… 学到jQuery时，这次我不再是拿来用用了，而是学习它的设计模式并自己模仿实现JQuery的部分API\n 👉学习jQuery的设计模式——手写jQuery\njQuery操作元素 选取元素 jQuery基础语法是：$(selector).action()——\u0026ldquo;选取元素，对其操作\u0026rdquo;，所以第一步就是学习jQuery 如何获取元素。\njQuery 使用 CSS 选择器来选取 HTML 元素，使用 XPath 表达式来选择带有给定属性的元素，也可以是使用特有的过滤表达式来选取元素。\ncss选择器 jQuery的选择器表达式可以是CSS 选择器来选取 HTML 元素\n$(\u0026quot;p\u0026quot;) 选取 \u0026lt;p\u0026gt; 元素。\r$(\u0026quot;p.intro\u0026quot;) 选取所有 class=\u0026quot;intro\u0026quot; 的 \u0026lt;p\u0026gt; 元素。\r$(\u0026quot;p#demo\u0026quot;) 选取所有 id=\u0026quot;demo\u0026quot; 的 \u0026lt;p\u0026gt; 元素。\r XPath表达式 jQuery的选择器表达式可以是XPath 表达式来选择带有给定属性的元素\n$(\u0026quot;[href]\u0026quot;) 选取所有带有 href 属性的元素。\r$(\u0026quot;[href='#']\u0026quot;) 选取所有带有 href 值等于 \u0026quot;#\u0026quot; 的元素。\r$(\u0026quot;[href!='#']\u0026quot;) 选取所有带有 href 值不等于 \u0026quot;#\u0026quot; 的元素。\r$(\u0026quot;[href$='.jpg']\u0026quot;) 选取所有 href 值以 \u0026quot;.jpg\u0026quot; 结尾的元素。\r 过滤表达式 jQuery的选择器表达式可以是jQuery特有的表达式 ，对元素进行过滤，获取到特定的元素\n$('a:first') //选择网页中第一个a元素\r$('tr:odd') //选择表格的奇数行\r$('#myForm :input') // 选择表单中的input元素\r$('div:visible') //选择可见的div元素\r$('div:gt(2)') // 选择所有的div元素，除了前三个\r$('div:animated') // 选择当前处于动画状态的div元素\r 查找元素 jQuery提供了在DOM树上移动的方法来查找元素，从被选（当前的）元素开始，在DOM树中向上移动（祖先），向下移动（子孙），水平移动（同胞），这种移动被也称为对 DOM 进行遍历。\n$(\u0026quot;span\u0026quot;).parent();//返回每个 \u0026lt;span\u0026gt; 元素的的直接父元素\r$(\u0026quot;span\u0026quot;).parents();//返回所有 \u0026lt;span\u0026gt; 元素的所有祖先\r$(\u0026quot;div\u0026quot;).children();//返回每个 \u0026lt;div\u0026gt; 元素的所有直接子元素\r$(\u0026quot;div\u0026quot;).find(\u0026quot;span\u0026quot;);//返回属于 \u0026lt;div\u0026gt; 后代的所有 \u0026lt;span\u0026gt; 元素\r$(\u0026quot;h2\u0026quot;).siblings();//返回 \u0026lt;h2\u0026gt; 的所有同胞元素\r$(\u0026quot;h2\u0026quot;).next();//返回 \u0026lt;h2\u0026gt; 的下一个同胞元素\r//三个最基本的过滤方法是：first(), last() 和 eq()\r$(\u0026quot;div p\u0026quot;).first();//first() 方法返回被选元素的首个元素\r$(\u0026quot;div p\u0026quot;).last();//last() 方法返回被选元素的最后一个元素\r$(\u0026quot;p\u0026quot;).eq(1);//选取第二个 \u0026lt;p\u0026gt; 元素\r 创建元素 创建新元素的方法非常简单，只要把新元素直接传入jQuery的构造函数就行了：\n 但是在上文介绍jQuery的基本语法中，括号中的内容是选择器，为什么现在可以直接传入HTML内容来创建元素？\n这就是因为jQuery使用重载的设计模式。\n $('\u0026lt;p\u0026gt;Hello\u0026lt;/p\u0026gt;');\r$('\u0026lt;li class=\u0026quot;new\u0026quot;\u0026gt;new list item\u0026lt;/li\u0026gt;');\r 元素的取值和赋值 jQuery使用同一个API，根据接收参数的不同，来完成取值（getter）或赋值（setter），即\u0026quot;取值器\u0026quot;与\u0026quot;赋值器\u0026quot;合一，这也是jQuery中使用的一种优秀的设计模式。\n 举例：  $('h1').html(); //html()没有参数，表示取出h1的值\r$('h1').html('Hello'); //html()有参数Hello，表示对h1进行赋值\r  常见的取值和赋值函数  .html() 取出或设置html内容\r.text() 取出或设置text内容\r.attr() 取出或设置某个属性的值\r.width() 取出或设置某个元素的宽度\r.height() 取出或设置某个元素的高度\r.val() 取出某个表单元素的值\r  如果结果集包含多个元素，那么赋值的时候，将对其中所有的元素赋值。 取值的时候，则是只取出第一个元素的值（.text()例外，它取出所有元素的text内容）\n 移动元素 ​ jQuery提供两组方法，来操作元素在网页中的位置移动。一组方法是直接移动该元素，另一组方法是移动其他元素，使得目标元素达到我们想要的位置\n 举例：  //第一种方法是使用.insertAfter()\r//把div元素移动p元素后面\r$('div').insertAfter($('p'));\r//第二种方法是使用.after()\r//把p元素加到div元素前面\r$('p').after($('div'));\r  二者区别：返回的元素不一样。第一种方法返回div元素，第二种方法返回p元素。\n  类似操作方法共4对  .insertAfter()和.after() //在现存元素的外部，从后面插入元素\r.insertBefore()和.before() //在现存元素的外部，从前面插入元素\r.appendTo()和.append() //在现存元素的内部，从后面插入元素\r.prependTo()和.prepend() //在现存元素的内部，从前面插入元素\r 删除元素 .remove()——将匹配元素集合从DOM中删除。（注：同时移除元素上的事件及 jQuery 数据）\n.detach()——从DOM中去掉所有匹配的元素（注：保留元素上的事件及 jQuery 数据）\n.empty()——从DOM中移除集合中匹配元素的所有子节点\n链式操作 jquery的核心操作：提供一个函数，参数是选择器，函数内部根据选择器获取这些元素后，返回一个jQuery对象（jquery函数构造出来的对象），后续每一步的jQuery操作也都是返回一个jQuery对象，就实现了链式操作。\n$('#test2').find('.child').addClass('green').addClass('blue')\r jQuery还提供了.end()方法，使得结果集可以后退一步：\n$('#parent').find('.child').addClass('green').end().addClass('old');//退回到选中的parent上添加old类属性\r PS：关于jQuery中其他API，事件、Ajax……参考jQuery中文文档\n JQuery中的设计模式 模仿jQuery实现其中的部分API后，也学习到了jQuery中各种优秀的设计模式，现在来简单总结一下。\n 设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，简单来说就是对优秀的代码模板，起个专业的名字。\n 链式调用 每一步的jQuery操作，返回的都是一个jQuery对象，参考上文中的链式操作\n函数重载 构造函数$()支持多种参数\n 参数：HTML —— 创建元素 参数：选择器 —— 查找元素  下面的代码模拟了jQuery中重载的实现：\nif (typeof selectorOrArrayOrTemplate === \u0026quot;string\u0026quot;) {\rif (selectorOrArrayOrTemplate[0] === \u0026quot;\u0026lt;\u0026quot;) {\r// 创建 elements = [createElement(selectorOrArrayOrTemplate)];\r} else {\r// 查找 elements = document.querySelectorAll(selectorOrArrayOrTemplate);\r}\r} else if (selectorOrArrayOrTemplate instanceof Array) {\relements = selectorOrArrayOrTemplate;\r}\r getter/setter jQuery使用同一个API，根据接收参数的不同，来完成取值（getter）或赋值（setter）\n适配器 jQuery针对不同浏览器使用不同代码\n如下代码中：innerText是IE支持的DOM操作，textContent是其他浏览器支持的DOM操作\ntext(node, string) {\rif (arguments.length === 2) {\rif ('innerText' in node) { //适配不同的浏览器\rnode.innerText = string //ie\r} else {\rnode.textContent = string //chrome/firefox\r}\r} else if (arguments.length === 1) {\rif ('innerText' in node) { //适配不同的浏览器\rreturn node.innerText\r} else {\rreturn node.textContent\r}\r}\r}\r 别名 避免浪费内存，jQuery中把所有共有的API放在了jQuery.prototype（原型）中，并为其起了别名jQuery.fn\nwindow.$ = window.jQuery\rjQuery.fn = jQuery.prototype\r 并且可以用原型继承实现插件系统\n$.fn.modal = function(){ ... }\r$('#div1').modal()\r 用闭包来隐藏细节 对象中各种函数和获得的elements(元素）形成闭包，让用户只能通过函数来操作元素，隐藏了细节\n不使用new的构造函数 通过直接调用函数，返回一个对象的方法来得到jQuery对象。\n参考 jQuery 都过时了，那我还学它干嘛？\njQuery设计思想\njQuery中文文档\n","date":"2020-12-07","permalink":"https://heeeyueee.github.io/post/jquery%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%85%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","tags":["JavaScript","DOM"],"title":"jQuery的使用与其设计模式"},{"content":" 选择排序、快速排序、计数排序、归并排序\n 选择排序 递归写法 let numbers = [2, 87, 4, 64, 73, 8, 92]\rlet min = (numbers) =\u0026gt; {\rif (numbers.length \u0026gt; 2) {\rreturn min([numbers[0], min(numbers.slice(1))])\r} else {\rreturn Math.min.apply(null, numbers)\r}\r}\rlet minIndex = (numbers) =\u0026gt; numbers.indexOf(min(numbers))\rlet sort = (numbers) =\u0026gt; {\rif (numbers.length \u0026gt; 2) {\rlet index = minIndex(numbers)\rlet min = numbers[index]\rnumbers.splice(index, 1)\rreturn [min].concat(sort(numbers))\r} else {\rreturn numbers[0] \u0026lt; numbers[1] ? numbers : numbers.reverse()\r}\r}\rsort(numbers)\r 循环写法 let minIndex = (numbers) =\u0026gt; {\rlet min = 0\rfor (let i = 1; i \u0026lt; numbers.length; i++) {\rif (numbers[i] \u0026lt; numbers[min]) {\rmin = i\r}\r}\rreturn min\r}\rlet swap = (Array, index, i) =\u0026gt; {\rlet temp = Array[index]\rArray[index] = Array[i]\rArray[i] = temp\r}\rlet sort = (numbers) =\u0026gt; {\rfor (let i = 0; i \u0026lt; numbers.length - 1; i++) {\rlet index = minIndex(numbers.slice(i)) + i\rif (i != index) {\rswap(numbers, index, i)\r}\r}\rreturn numbers\r}\r tip\n1.所有的递归都可以变为循环\n2.swap中要传入参数Array（Array的地址），函数直接对Array进行操作，如果使用swap(numbers[i],numbers[j])只是传的两个值的简单复制，不会对原数组进行修改。\n快速排序 let sort = (numbers) =\u0026gt; {\rif (numbers.length \u0026lt;= 1) {\rreturn numbers\r}\rlet flagIndex = Math.floor(numbers.length / 2)\rlet flag = numbers.splice(flagIndex, 1)[0] //splice后的返回值是数组\rlet left = []\rlet right = []\rfor (let i = 0; i \u0026lt; numbers.length; i++) {\rif (numbers[i] \u0026lt; flag) {\rleft.push(numbers[i])\r} else {\rright.push(numbers[i])\r}\r}\rreturn sort(left).concat([flag], sort(right))\r}\r 归并排序 let sort = (numbers) =\u0026gt; {\rif (numbers.length === 1) return numbers\rlet middle = Math.floor(numbers.length / 2)\rlet left = numbers.slice(0, middle)\rlet right = numbers.slice(middle)\rconsole.log(left, right);\rreturn merge(sort(left), sort(right))\r}\rlet merge = (a, b) =\u0026gt; {\rif (a.length === 0) return b\rif (b.length === 0) return a\rreturn a[0] \u0026gt; b[0] ? [b[0]].concat(merge(a, b.slice(1))) : [a[0]].concat(merge(a.slice(1), b))\r}\r 计数排序 let sort = (numbers) =\u0026gt; {\rlet hashTable = {},\rmax = 0,\rresult = []\rfor (let i = 0; i \u0026lt; numbers.length; i++) {\rif (numbers[i] in hashTable) {\rhashTable[numbers[i]] += 1\r} else {\rhashTable[numbers[i]] = 1\r}\rif (numbers[i] \u0026gt; max) max = numbers[i]\r}\rfor (let j = 0; j \u0026lt; max; j++) {\rif (j in hashTable) {\rfor (let i = 0; i \u0026lt; hashTable[j]; i++) {\rresult.push(j)\r}\r}\r}\rreturn result\r}\r","date":"2020-12-01","permalink":"https://heeeyueee.github.io/post/%E4%BD%BF%E7%94%A8js%E5%AE%9E%E7%8E%B0%E5%9B%9B%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","tags":["JavaScript","算法"],"title":"使用JS实现四种排序算法"},{"content":" JavaScript数组小结~\n  在之前学习完数组，对数组进行详细总结后，发现实际操作中总会记混各个方法的返回值，也会忘记方法是否会改变原数组，于是在这篇博客中来一个小结\n 方法分类回顾 直接上图来回顾之前学到的各个方法吧！\n原数组与返回值    方法 返回值 是否改变原数组     push(v) 返回数组的新长度 ✔️   pop() 返回删除的元素 ✔️   shift() 返回删除的元素 ✔️   unshift() 返回数组的新长度 ✔️   reverse() 返回颠倒后的数组 ✔️   sort() 返回排序后的数组 ✔️   concat() 返回连接后的新数组 ❌   slice(begin,end) 返回由begin 和 end 决定的原数组的浅拷贝 ❌   splice(begin,deleteCount,items) 返回被删除元素组成的数组 ✔️   every() 返回一个布尔值 ❌   forEach() undefined ❌   some(） 返回一个布尔值 ❌   filter() 一个新的、由符合条件的元素组成的数组 ❌   map() 一个由原数组每个元素执行回调函数的结果组成的新数组 ❌ (基础类型)✔️(引用类型)   reduce() 函数累计处理的结果 ❌    详解  挑出几个常用易错的进行记录\n slice（） slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。\nlet arr = [1, 2, 3, 4, 5]\rlet a = arr.slice(0, 2)\rconsole.log(a);//[1,2]\rconsole.log(arr);//[1,2,3,4,5]\r splice（）  splice()方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法将改变原数组。\n array.splice(start, deleteCount, arguments)\r复制代码\r  start  指定修改的开始位置（从0计数） deleteCount 整数，表示要移除的数组元素的个数 arguments 要添加进数组的元素,从start 位置开始。如果不指定，则 splice() 将只删除数组元素  let arr = [1, 2, 3, 4, 5]\rlet a = arr.splice(1, 2, 22, 33)\rconsole.log(a);//[2,3]\rconsole.log(arr);//[1,22,33,4,5]\r map（） 关于map方法是否原数组可以参考下面博客：\nJS 数组map()方法到底会不会改变原数组\n","date":"2020-11-30","permalink":"https://heeeyueee.github.io/post/js%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%98%AF%E5%90%A6%E6%94%B9%E5%8F%98%E5%8E%9F%E6%95%B0%E7%BB%84%E5%92%8C%E5%85%B6%E8%BF%94%E5%9B%9E%E5%80%BC/","tags":["JavaScript"],"title":"JS数组方法是否改变原数组和其返回值"},{"content":" 总结JS运算符和易错的点\n 关于运算符，各种语言都大同小异，记录一下JS运算符中特别的地方。\n算术运算符 JavaScript 共提供10个算术运算符，用来完成基本的算术运算。\n +、-、*、 /、 **、 %、 ++、 --、数值运算符： + 、负数值运算符：-\n   加法运算符（+）用于字符串时是连接运算符，且字符串只支持+这一个运算符、任何类型数据+字符串时都会把该数据先转化为字符串再连接字符串。\n  除了加法运算符，其他算术运算符（比如减法、除法和乘法）都只有单功能。它们的规则是：所有运算子一律转为数值，再进行相应的数学运算。\n  加法运算符（+）用于对象，必须先转成原始类型的值，然后再相加。\n  指数运算符（**）完成指数运算，运算符前是底数，后面是指数。2^2=2**2=4\n  尽量少用自增自减（for循环可以），使用a+=1\n  关于自增自减运算符，变量放在前就返回变量操作前的值，变量在后就返回变量操作后的值 ，下面给出示例\nvar x = 1; var y = 1;\rx++ // 1 ++y // 2\rx--//1\r--x//0\r   数值运算符+的作用在于可以将任何值转为数值\n+true // 1\r+[] // 0\r+{} // NaN\r   负数值运算符-功能和数值运算符相同，但是得到的值正负相反。\n  比较运算符 JavaScript 一共提供了8个比较运算符\n  \u0026gt;大于、\u0026lt; 小于、\u0026lt;= 小于或等于、\u0026gt;= 大于或等于、== 相等、=== 严格相等、!= 不相等、!== 严格不相等运算符\n 关于比较运算符，最重要的就是模糊==和严格===的使用\n模糊==比较规则：\n类型相同时，比较两个值是否相等；\n类型不相同时，会将它们转换成同一个类型，再用严格相等运算符进行比较。\n下面是x==y的真值表：\n//特殊例子\r[]==false //true\r[[]]==false //true\r{}==false //false\r 严格===比较规则：\n类型相同时，比较两个值是否相等；\n类型不相同时， 直接不相等， 返回false\n类型是对象时就判断地址是不是一样 ，地址不一样就返回false，[]=== [] 是false\n所以判断时尽量使用严格===，不容易出错！\n//特殊例子\r[] === [] //false\r{} === {} //false\rNaN === NaN //false\r 布尔运算符 布尔运算符用于将表达式转为布尔值，一共包含四个运算符\n 取反运算符：!、且运算符：\u0026amp;\u0026amp;、或运算符：||、三元运算符：?:\n   对于非布尔值，取反运算符!会将其转为布尔值。以下六个值取反后为true，其他值都为false。\nundefined null false 0 NaN 空字符串（''）\r   对一个值连续做两次取反运算，等于将其转为对应的布尔值\n  防御性编程 : console \u0026amp;\u0026amp; console.log \u0026amp;\u0026amp; console.log(\u0026lsquo;hi\u0026rsquo;) 检查console.log方法是否可以用\n  且运算\u0026amp;\u0026amp;符可以多个连用，这时返回第一个布尔值为false的表达式的值或最后一个表达式的值。\nconsole \u0026amp;\u0026amp; console.log \u0026amp;\u0026amp; console.log('hi') //检查console.log方法是否可以用\r   或运算符||也用于多个表达式的求值返回第一个布尔值为true的表达式的值\n  或运算符||也可以用于为变量设置默认值\na=a||100 //如果a没有值就给他默认值100\r 但上例中，a为5个falsy时有bug，新版语法中直接可以在函数声明时指定a的默认值\n  二进制运算符  |二进制或、\u0026amp;二进制与、~二进制否、^异或、\u0026lt;\u0026lt;左移、\u0026gt;\u0026gt;右移、\u0026gt;\u0026gt;\u0026gt;头部补零的右移\n 二进制运算符不常用，随用随查，介绍几个妙用：\n  使用与运算符\u0026amp;判断奇偶\n二进制与运算符（\u0026amp;）的规则是逐位比较两个运算子，两个二进制位之中只要有一个位为0，就返回0，否则返回1\n把数字变为二进制时, 奇数最后一位是1,偶数最后一位是0\n偶数 \u0026amp; 1 = 0\r奇数 \u0026amp; 1 = 1\r   使用~~, \u0026gt;\u0026gt;, \u0026lt;\u0026lt;, \u0026gt;\u0026gt;\u0026gt;, |来取整\n所有的位运算都只对整数有效。二进制运算遇到小数时，也会将小数部分舍去，只保留整数部分。\n~~2.9 // 2\r2.9 \u0026gt;\u0026gt; 0 //2\r   使用^来交换 a b 的值\nvar a = 5\rvar b = 8\ra ^= b\rb ^= a\ra ^= b\rconsole.log(a) // 8\rconsole.log(b) // 5\r 可以最简便的使用[a,b]=[b,a]来交换值\n  其他运算符 void 运算符 void运算符的作用是执行一个表达式，然后不返回任何值，或者说返回undefined。\n最主要的用法是在a标签的超级链接中插入代码防止网页跳转：\n\u0026lt;a HREF=\u0026quot;javascript:void(0)\u0026quot;\u0026gt;单此处什么也不会发生\u0026lt;/a\u0026gt; \u0026lt;a HREF=\u0026quot;javascript:void(document.form.submit())\u0026quot;\u0026gt; 单此处提交表单\u0026lt;/a\u0026gt;\r\u0026lt;a href=\u0026quot;javascript:void(0)\u0026quot;onclick=\u0026quot;fn()\u0026quot;\u0026gt;点我执行函数\u0026lt;/a\u0026gt;\r 点运算符 语法：对象.属性名 = 属性值\n点运算符只能用在对象上 ，如果是其他类型使用，JS会自动将其封装为一个对象（一次性），number 会变成 Number 对象，string 会变成 String 对象，bool 会变成 Boolean 对象……\n运算符优先级 运算符的优先级十分难记，直接使用圆括号来提升表达式的优先级。\n","date":"2020-11-25","permalink":"https://heeeyueee.github.io/post/javascript%E8%BF%90%E7%AE%97%E7%AC%A6%E6%98%93%E9%94%99%E7%82%B9/","tags":["JavaScript"],"title":"JavaScript运算符易错点"},{"content":" 这是我在JS学习路上的大山，不断学习，不断更新中~\n  关于JS函数有9个十分重要但又不好理解的要素，随着不断学习，对他们认识也一直在改变，先从一个小白的视角来总结一下，对于其中难懂的要素会单独写博客来总结。\n    时间 修改内容     2020.11.23 第一版    9个要素  调用时机 👉JS函数的执行时机 作用域 👉(会单独写博客) 闭包 👉(和作用域一起写博客) 形式参数 返回值 调用栈 arguments（除了箭头函数） this（除了箭头函数）👉(会单独写博客)  每一个函数都有这9个要素，但ES6新版语法的箭头函数没有arguments和this\n定义函数  函数其实是处理数据的方法，JavaScript 把它当成一种数据类型，可以赋值给变量，这为编程带来了很大的灵活性，也为 JavaScript 的“函数式编程”奠定了基础。\n 函数也是对象,先从最简单的定义函数开始：\n具名函数 function 函数名(形式参数1, 形式参数2){\r语句\rreturn 返回值\r}\r 这种方式声明的函数，全局可调用，并且JS会进行函数提升，把它提升到代码的最前面。\n匿名函数 let a = function(x, y){ return x+y }\r 上面的具名函数，去掉函数名就是匿名函数，上面例子中使用函数表达式将匿名函数赋值给变量，这里的赋值跟将对象赋值给变量一样，a中存储的就是函数对象的地址。之后就可以通过a()来调用函数。\n💁🏼‍♀️插一嘴：a与a()\n a是指函数本身 ，a()是指调用（执行）这个函数 ，a是一个变量保存了函数体的地址，如果一个变量存的是一个函数的地址，那通过变量来执行函数时就是对函数的引用。\n 立即执行函数\n 立即执行函数就是通过匿名函数来实现的\n 在ES5时代，为了得到局部变量，必须引入一个函数，在函数里去声明局部变量，但是这个函数如果有名字，就得不偿失，于是这个函数必须是匿名函数。\n于是声明匿名函数，然后立即加个 () 执行它，并在匿名函数前面加个运算符来让其符合JS语法，!、~、()、+、-运算符都可，这种方法形成的函数就是立即执行函数。\n!function(i){\r语句\r}(i)\r ES6新语法出现后，想要得到局部变量就十分简单了，使用 let/const的块作用域特性来声明局部变量\n{\rlet i = 'moji';\r}\r 箭头函数 箭头函数是函数声明的简写形式，在使用递归调用、构造函数、事件处理器时不建议使用箭头函数。\n 无参数时使用空扩号即可 函数体为单一表达式时不需要 return 返回处理，会自动返回表达式计算结果，可以省略花括号 只有一个参数时可以省略括号  (参数1, 参数2, …, 参数N) =\u0026gt; { 函数声明 }\r(参数1, 参数2, …, 参数N) =\u0026gt; 表达式（单一）\r//相当于：(参数1, 参数2, …, 参数N) =\u0026gt;{ return 表达式; }\r// 当只有一个参数时，圆括号是可选的：\r(单一参数) =\u0026gt; {函数声明}\r单一参数 =\u0026gt; {函数声明}\r// 没有参数的函数应该写成一对圆括号。\r() =\u0026gt; {函数声明}\r 构造函数 let f = new Function('x', 'y', 'return x+y')\r 所有函数都是 Function 构造出来的,包括 Object、Array、Function\n调用时机 JS函数的执行时机和函数被调用的时机有关，函数被调用时才会被执行，调用时机不同，函数的执行结果也不同。\n关于调用时机引发的问题 ，另一篇博客有详细探讨👉JS函数的执行时机\n作用域  先记录一下对函数作用域最直白的理解，再读完《你不知道的JavaScript上卷》之后，再单独写一篇博客来总结。\n 只有一个全局作用域就是window，每个函数都会默认创建一个作用域，编译器运行时会将变量定义在所在作用域，作用域外就无法访问到变量。所以，变量可分为全局变量和局部变量，在顶级作用域（window）声明的变量是全局变量，其他都是局部变量。.如果在一个函数里面声明了let const声明了一个变量，就是局部变量，作用域在函数里面\n 作用域规则——「就近原则」\n  如果多个作用域有同名变量 a，那么查找 a 的声明时，就向上取最近的作用域 确定是哪个作用域的变量a的时候是不看函数执行的，只有确定变量a的值的时候才和函数的执行有关 跟函数执行没有关系的作用域叫做静态（词法）作用域，反之，动态作用域  例1：\nfunction f1(){\rlet a = 1\rfunction f2(){\rlet a = 2\rfunction f3(){\rconsole.log(a)\r}\ra = 22\rf3() }\rconsole.log(a) a = 100\rf2()\r}\rf1()\r// 1 // 22\r 解析：函数 f3中console.log(a)的a可以通过就近原则确认是第四行声明的变量a，但是f3被调用前a被重新赋值为22，可以得到打印为22\n闭包 JS的函数会就近的选择最近的变量来执行，如果一个函数用到了外部的变量，那么这个函数加这个变量就叫做闭包，闭包一般在子函数（嵌套函数）本身作用域以外执行。例1中f3用到了外部的变量a，a 和 f3 组成了闭包。\n形式参数 形式参数的意思就是非实际参数，形式参数可以认定为变量声明，调用函数时形参都是对实参内存中stack里存储的值进行复制，普通类型直接复制值，复制类型（对象）复制是地址。\nfunction add(x, y){\rreturn x+y\r}\r// 其中 x 和 y 就是形参，因为并不是实际的参数\radd(1,2)\r// 调用 add 时，1 和 2 是实际参数，会被赋值给 x y\r 形参可认为是变量声明\n// 上面代码近似等价于下面代码\rfunction add(){\rvar x = arguments[0]\rvar y = arguments[1]\rreturn x+y\r}\r 返回值 每个函数都有返回值且只有执行完的函数才有返回值，没有写return的函数 ，返回值undefined\n调用栈 调用栈就是执行一个函数前会在栈里记录（压入）当前所处的环境位置（执行完函数后要回到的环境位置），等函数执行完毕，再弹出刚才记录的位置信息，回到之前位置继续执行后续代码。\n递归函数的调用栈：先递进后回归，递进的过程就是把环境位置信息一步步压栈的过程，f(4)就压入了4四次，回归就是把位置环境信息一步步弹栈，子函数得到结果后再一步步的回归到父环境得到最终结果（参考上图）。\narguments arguments对象是所有（非箭头）函数中都可用的局部变量。arguments是函数所有参数组成的伪数组（没有数组的共有属性），可以使用arguments对象在函数中引用函数的参数。\nfunction func1(a, b, c) {\rconsole.log(arguments[0]);\r// expected output: 1\rconsole.log(arguments[1]);\r// expected output: 2\rconsole.log(arguments[2]);\r// expected output: 3\r}\r this 🤟先来了解一下this的起源：\n写函数时，在还不知道对象的名字（对象还没有声明）时拿到一个对象的属性，可以怎么做呢？ 第一种：使用形式参数，调用函数的时候再传入 ，python使用了这个方法\nlet person = {\rname: 'moji',\rsayHi(p){\rconsole.log(`你好，我叫` + p.name)\r}\r}\rperson.sayHi(person)  ​ 这显然和 JS 中对象调用函数的方式不一样，JS中是直接person.sayHi()，\n​ 第二种：JS解决方法是，在每个函数里加入了this，可以使用this来调用还不知道名字的对象的属性值，在被对象调用时，this里的值就是对象的地址，使用this来获取对未知对象的引用。\nlet person = {\rname: 'moji',\rsayHi(this(省略)){\rconsole.log(`你好，我叫` + this.name)\r}\r}\rperson.sayHi()\r person.sayHi()会隐式地把 person（person 是个地址） 作为 this 传给 sayHi，这样，每个函数都能用 this 获取一个未知对象的引用了。\n🤏简单来说，this就是最终调用函数的对象\nps：函数里不给其他条件，this默认指向window，箭头函数自己没有this，函数外面的this就函数里调用的this，call也无法使用\ncall()和apply() call 方法第一个参数也是作为函数上下文的对象，后面传入的是一个参数列表，而不是单个数组。\napply 方法传入两个参数：一个是作为函数上下文的对象，另外一个是作为函数参数所组成的数组。\n作用：\n  改变this的指向\n  调用函数\nperson.sayHi()=person.sayHi.call(person) ，不需要传this时，使用undefined来占位\n  bind() 它和 call 很相似，接受的参数有两部分，第一个参数是是作为函数上下文的对象，第二部分参数是个列表，可以接受多个参数。使用bind来绑定this，让this不再改变\n","date":"2020-11-23","permalink":"https://heeeyueee.github.io/post/js%E5%87%BD%E6%95%B0%E7%9A%849%E5%A4%A7%E8%A6%81%E7%B4%A0/","tags":["JavaScript","JS函数"],"title":"JS函数的9大要素"},{"content":" 探讨关于JS函数的执行时机的问题~\n JS函数的执行时机和函数被调用的时机有关，函数被调用时才会被执行，调用时机不同，函数的执行结果也不同。\n先通过几个例子来理解这句话：\n例 1：\nlet a = 1\rfunction fn(){\rconsole.log(a)\r}\r 结果：a不会被打印，因为没有调用函数，函数未被执行。\n例 2：\nlet a = 1\rfunction fn(){\rconsole.log(a)\r}\rfn()\r// 1\r 结果：a被打印为1。\n例 3：\nlet a = 1\rfunction fn(){\rconsole.log(a)\r}\ra = 2\rfn()\r// 2\r 结果：a被打印为2, 可以通过函数声明的位置确认，函数里的变量a是离函数最近的let声明的变量a，但在函数被调用前a被赋值为2。\n例 4：\nlet a = 1\rfunction fn(){\rconsole.log(a)\r}\rfn()\ra = 2\r// 1\r 结果：a被打印为1, 可以通过函数声明的位置确认，函数里的变量a是离函数最近的let声明的变量a，并且在函数调用前a的值未被改变。\n例 5：\nlet a = 1\rfunction fn(){\rsetTimeout(()=\u0026gt;{\rconsole.log(a)\r},0)\r}\rfn()\ra = 2\r// 2\r 结果：a被打印为2\n原因：console.log(a)是异步执行的，实际上的执行时间是a=2赋值执行之后\n先来看看setTimeout()函数的原理\n💁🏼‍♀️插一嘴：异步\n Javascript语言的执行环境是\u0026quot;单线程\u0026quot;。也就是指一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务。为了解决阻塞问题，Javascript语言将任务的执行模式分成两种：同步和异步。setTimeout函数就可以让任务异步执行。\n var timerId = setTimeout(func|code, delay)\r   setTimeout函数接受两个参数，第一个参数func|code是将要推迟执行的函数名或者一段代码，第二个参数delay是推迟执行的毫秒\n数。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器。\n  计时器到达时间点,计时器里事件处理程序或回调函数都不会立即运行，而是立即排队，一旦线程有空闲就执行。\n  如果这个时间设为 0，就代表立即插入队列，但不是立即执行，仍然要等待前面代码执行完毕，只有在 JS线程中没有任何同步代码要执行的前提下才会执行异步代码。\n  例 6：\nlet i = 0\rfor(i = 0; i\u0026lt;6; i++){\rsetTimeout(()=\u0026gt;{\rconsole.log(i)\r},0)\r}\r//不是 0、1、2、3、4、5\r//而是 6 个 6\r setTimeout函数让console.log(i)变为异步执行，每次循环都会把console.log(i)加入队列，但要等待for循环执行完毕后（i的值变为6），才开始执行队列中的6个console.log(i)语句，因为i定义在全局作用域中，6个console.log(i)语句共享一个i的引用，所以打印为6个6。\n 让上面代码打印 0、1、2、3、4、5 的方法\n 方法一\nfor(let i = 0; i\u0026lt;6; i++){\rsetTimeout(()=\u0026gt;{\rconsole.log(i)\r},0)\r}\r// 0、1、2、3、4、5\r 参考方方老师博客：我用了两个月的时间才理解 let\n和例6相比，使用let在for循环语句的圆括号之内声明赋值，在圆括号之间会有一个隐藏的作用域,并且在每次执行循环体之前，JS 引擎会把 i 在循环体的上下文中重新声明及初始化一次。\n上面代码相当于\nfor(let i = 0; i\u0026lt;6; i++){\rlet i = 圆括号隐藏作用域中的i setTimeout(()=\u0026gt;{\rconsole.log(i)\r},0)\r}\r 这样的话，在for循环中，每次循环都会产生一个闭包作用域，i会被声明5次，产生5个不同的i，console.log(i)语句中的i不再是例6中for循环外的全局i，而是for循环语句内每次都重新声明赋值的i，第一次循环的i被声明赋值为0，加入队列的语句为 console.log(0)，第二次\u0026hellip;\u0026hellip;所以结果是0、1、2、3、4、5\n方法二\n参考博客：JS 函数的执行时机\nfor (var i = 0; i \u0026lt;6;i++){\r!function(i){\rsetTimeout(()=\u0026gt;{\rconsole.log(i),1000})\r}(i) }\r 在for循环体内使用立即执行函数时，都每次循环都会创建一个新的作用域，使得setTimeout函数的回调可以将新的作用域封闭在每个循环内部，每个循环中都会有一个有正确值的变量i。\n","date":"2020-11-21","permalink":"https://heeeyueee.github.io/post/js%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/","tags":["JavaScript","JS函数"],"title":"JS函数的执行时机"},{"content":" 总结JavaScript数组及相关方法~\n 数组对象 JavaScript里的数组和我们认识的典型的数组不一样，本质上是一种特殊的对象。\n 典型的数组:\n 元素的数据类型相同 使用连续的内存存储 通过数字下标获取元素   先看看JS数组在内存中的存储：\n  JS数组中访问下标是字符串类型的（和JS对象一样），并且可以不已数字为下标，可以更改为任意的字符串。访问时：arr[\u0026ldquo;1\u0026rdquo;]\n也可以直接使用arr[1] （非字符串的键名会被转为字符串）。不能使用访问对象的点语法来访问数组元素\n  元素的数据类型可以不同,任何类型的数据，都可以放入数组。\n  内存不一定是连续的（ 对象是随机存储的）\n  JS中数组和对象的区别是：\n​ 数组成员的键名是固定的（默认总是0、1、2\u0026hellip;），因此数组不用为每个元素指定键名，而对象的每个成员都必须指定键名。\n属性 length JavaScript 使用一个32位整数，保存数组的元素个数。这意味着，数组成员最多只有 4294967295 个（232 - 1）个，也就是说length属性的最大值就是 4294967295。\n 只要是数组，就一定有length属性。 该属性是一个动态的值，特殊情况是JS数组的数字键不需要连续，length值等于键名中的最大整数加上1。 length属性是可写的，使用length属性可以直接删数组元素，增数组元素  创建数组 新建 let arr=[1,2,3]\rlet arr=new Array(1,2,3)\rlet arr=new Array(3)\r  new Array()——一个参数代表新建数组的length，多个参数代表数组的元素  转化 split()  split() 方法使用指定的分隔符字符串将一个String对象分割成子字符串数组，以一个指定的分割字串来决定每个拆分的位置。\n 简单来说，split方法最常用的就是参数中指定一个分隔符来把字符串分割为数组,有一个和它反作用的方法join。\nvar str = 'user-1,user-2,user-3';\rvar result = str.split(',');\rconsole.log( result );//[\u0026quot;user-1\u0026quot;, \u0026quot;user-2\u0026quot;, \u0026quot;user-3\u0026quot;]\r Array.from  Array.from() 方法从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。\n 简单来说，Array.from将类数组对象转换成数组，比如String、set对象、map对象\u0026hellip;\u0026hellip;\n**PS：**类数组的原型链中并没有数组的原型（没有数组共有的属性），可以通过Array.from来进行转化就可以获得共有属性\nArray.from('foo'); // [ \u0026quot;f\u0026quot;, \u0026quot;o\u0026quot;, \u0026quot;o\u0026quot; ]\r 👉跟多关与Array.from的用法：Array.from() 五个超好用的用途\nconcat()  concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。\n var alpha = ['a', 'b', 'c'];\rvar numeric = [1, 2, 3];\ralpha.concat(numeric); // result in ['a', 'b', 'c', 1, 2, 3\r slice()  slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。\n 简单来说，slice翻译为切，两个参数代表从什么位置起切到什么位置止，返回一个新数组。\nconst arr = ['a', 'b', 'c', 'd', 'e'];\rconsole.log(arr.slice(2));\r// Array [\u0026quot;c\u0026quot;, \u0026quot;d\u0026quot;, \u0026quot;e\u0026quot;]\rconsole.log(arr.slice(2, 4));\r// Array [\u0026quot;c\u0026quot;, \u0026quot;d\u0026quot;]\r  let arrcopy = arr.slice(0) ———— 可以用来复制一个数组 JS原生提供的方法都是浅拷贝  删元素 delete命令 和删除对象属性一样，使用delete命令来删除数组的元素，删除元素后数组的长度依旧不变，元素值变为empty\nlength  设置一个小于当前成员个数的值，该数组的元素数量会自动删除减少到length设置的值。 清空数组的一个有效方法，就是将length属性设为0  shift()  shift() 方法从数组中删除第一个元素，并返回该元素的值。此方法将改变原数组。\n let arr = [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;];\rfruits.shift(); // 移除 a 并作为返回值\ralert( fruits ); // b, c\r 💁🏼‍♀️插一嘴：\n JavaScript 中的数组既可以用作队列，也可以用作栈。它们允许你从首端/末端来添加/删除元素。\n这在计算机科学中，允许这样的操作的数据结构被称为 双端队列（deque）。\n pop()  pop()方法从数组中删除最后一个元素，并返回该元素的值。此方法将改变原数组。\n let arr = [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;];\rfruits.pop(); // 移除 c 并作为返回值\ralert( fruits ); // a, b\r 📍splice()  splice()方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法将改变原数组。\n array.splice(start, deleteCount, arguments)\r  start  指定修改的开始位置（从0计数） deleteCount 整数，表示要移除的数组元素的个数 arguments 要添加进数组的元素,从start 位置开始。如果不指定，则 splice() 将只删除数组元素。  splice()用法多多很灵活\n查元素 查对象方法  可以使用读取对象属性的方法，一种是使用点运算符（下标是非数值时使用），还有一种是使用方括号运算符（arr[1] 引号可以省略）。 使用for\u0026hellip;in来遍历数值下标和值  for循环 使用for\u0026hellip;in在遍历数组时，也会遍历到了非整数键。所以，不推荐使用for...in遍历数组，使用for循环和while来遍历数组（规定数组下标从0到length-1）。\nvar a = [1, 2, 3];\r// for循环\rfor(var i = 0; i \u0026lt; a.length; i++) {\rconsole.log(a[i]);\r}\r// while循环\rvar i = 0;\rwhile (i \u0026lt; a.length) {\rconsole.log(a[i]);\ri++;\r}\r forEach函数 遍历这个数组，每一次都调用这个函数\n[].forEach(function(value, index, array) {\r// ...\r});\rvar colors = ['a', 'b', 'c'];\rcolors.forEach(function (item) {\rconsole.log(item);\r});\r// a\r// b\r// c\r  value 遍历的数组内容 index 对应的数组索引 array 数组本身  💁🏼‍♀️插一嘴：\nfor循环和forEach的区别\n for循环和foreach大部分情况下都是可以通用的\n但for循环里面可以有break和continue\nfor循环是关键字，没有函数作用域，只有块级作用域，foreach是函数，拥有函数作用域\n 判断元素 includes()  includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。\n arr.includes(item) // 存在返回 true，否则返回false\r indexOf() arr.indexOf(item) // 存在返回索引， 否则返回-1\r find()  find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined\n arr.find(item = \u0026gt; item % 2 === 0 ) //找第一个偶数，并返回其值\r findIndex()  findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回-1。\n arr.findlndex(item = \u0026gt; item % 2 === 0) // 找第一个偶数的索引\r 增元素 push()  push() 方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度,改变原数组。\n arr.push(element1, ..., elementN)\r unshift()  unshift() 方法将一个或多个元素添加到数组的开头，并返回该数组的新长度(该方法修改原有数组**)**。\n arr.unshift(element1, ..., elementN)\r splice() 用法见上，用于在中间添加元素\n改元素 反转顺序reverse()  reverse() 方法将数组中元素的位置颠倒，并返回该数组。数组的第一个元素会变成最后一个，数组的最后一个元素变成第一个。该方法会改变原数组。\n const reversed = array1.reverse();\rconsole.log('reversed:', reversed);\r// \u0026quot;reversed:\u0026quot; Array [\u0026quot;3\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;1\u0026quot;]\r 自定义排序sort()  sort() 方法用原地算法对数组的元素进行排序，并返回数组。\n arr.sort([compareFunction])  关与compareFunction比较函数MDN中有详细的介绍👉MDN\n数组变换 map() 遍历数组的每个元素对并调用函数，返回结果数组，是n变n的操作。\nlet result = arr.map(function(item, index, array) {\r// 返回新值而不是当前元素\r})\r filter() filter 返回的是所有匹配元素组成的数组,是n变n-的操作。\nlet results = arr.filter(function(item, index, array) {\r// 如果 true item 被 push 到 results，迭代继续\r// 如果什么都没找到，则返回空数组\r});\r 📍reduce() arr.reduce 方法根据数组计算单个值,是n变1的操作。\nlet value = arr.reduce(function(accumulator, item, index, array) {\r// ...\r}, [initial]);\r 该函数一个接一个地应用于所有数组元素，并将其结果“搬运（carry on）”到下一个调用。\n参数：\n accumulator —— 是上一个函数调用的结果，第一次等于 initial（如果提供了 initial 的话）。 item —— 当前的数组元素。 index —— 当前索引。 arr —— 数组本身。  应用函数时，上一个函数调用的结果将作为第一个参数传递给下一个函数。\n因此，第一个参数本质上是累加器，用于存储所有先前执行的组合结果。最后，它成为 reduce 的结果。\n👉跟多关与reduce() 的用法：JS数组reduce()方法详解及高级技巧\n参考 MDN\nJS现代教程\n","date":"2020-11-19","permalink":"https://heeeyueee.github.io/post/js%E6%95%B0%E7%BB%84/","tags":["JavaScript"],"title":"JavaScript数组"},{"content":" 总结JS对象的基本用法~\n 声明对象 两个最基本的声明对象方式：\n字面量声明 字面量声明方法是Object构造函数创建对象方法的简写形式\nvar Student={}; var Student={'name':\u0026quot;moji\u0026quot;,'age':21}\r Object构造函数创建 var Student = new Object ({ 'name':\u0026quot;moji\u0026quot;,'age':21 });\rPerson.gender = 'female';\r  两种方法的缺点是同一个接口创建很多对象和，会产生大量的重复代码 👉更多声明对象的方法 参考博客：JS创建对象的几种方法  属性名和属性值 属性名   键名(属性名)是字符串，不是标识符，可以包含任意字符\n  引号可省略，省略之后就只能写标识符，但键名也还是字符串\n  保险情况下要加上引号，比如 属性名为1e2，js会先转化为100，再加上“”，属性名就变为“100”\nlet obj = {\r1: 'a',\r3.2: 'b',\r1e2: true,\r1e-2: true,\r.234: true,\r0xFF: true\r};\rObject.keys(obj)\r=\u0026gt; [\u0026quot;1\u0026quot;, \u0026quot;100\u0026quot;, \u0026quot;255\u0026quot;, \u0026quot;3.2\u0026quot;, \u0026quot;0.01\u0026quot;, \u0026quot;0.234\u0026quot;]\r   Object.keys(obj) 可以得到 obj 的所有 key\n  属性名新方法：可以用变量做属性名，[a]代表变量a\nlet p1 = 'name'\rlet obj = { p1 : 'moji'} //属性名为 'p1',不加 [ ] 的属性名会自动变成字符串\rlet obj = { [p1] : 'moji' } //属性名为 'name',加了 [ ] 则会当做变量求值\r   隐藏属性 JS 中每一个对象都有一个隐藏属性（__proto__）储存着共有属性组成的对象（原型）的地址\n读属性 读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。\nobject[变量] 方括号中可以放变量，.点运算符后面的会直接变字符串\nvar obj = {\rp: 'Hello World'\r};\robj.p // \u0026quot;Hello World\u0026quot;\robj['p'] // \u0026quot;Hello World\u0026quot;\r  使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理!!!     方法 说明     Object.keys(obj) 查看自身所有属性名   Object.values(obj) 查看自身所有属性值   Object.entries(obj) 查看自身所有属性名+属性值组成的键值对   console.dir(obj) 查看自身+共有属性    写属性 修改或增加属性\n直接赋值 点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值\nlet obj = {name: 'moji'} // name 是字符串\robj.name = 'moji' obj['name'] = 'moji' // name 是字符串\robj['na'+'me'] = 'moji'\rlet key = 'name'; let key = 'name';//obj.key 等价于 obj['key']\robj[key] = 'moji'\r 批量赋值 使用assign方法\nObject.assign(obj, {age: 18, gender: 'female'})\r 无法通过对象自身来修改或增加共有属性，可以对obj.__proto__.和Object.prototype的共有属性赋值来改变(不推荐)，推荐使用 Object.create来从创造对象起就指定修改其原型。\n删属性 使用delete 命令 ,delete命令用于删除对象的属性，删除成功后返回true\ndelete obj.xxx delete obj['xxx']\r  删除一个不存在的属性，delete不报错，而且返回true 删除后再读取该属性的值为undefined delete命令只能删除对象本身的属性，无法删除继承的属性  判断 in 运算符 in运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true，否则返回false。它的左边是一个字符串，表示属性名，右边是一个对象。\nvar obj = {'name' : 'moji' };\r'name' in obj // true\r'toString' in obj // true\r hasOwnProperty() 使用hasOwnProperty判断是否为对象自身的属性，是自身特定的属性返回true，是原型链上的属性返回false\nobj.hasOwnProperty('toString') // false\r 属性的遍历 除了上面说到的Object.keys(obj)、Object.values(obj)、Object.entries(obj)、console.dir(obj)，还可以使用for\u0026hellip;in循环来遍历对象，得到属性值和属性名\nvar obj = {'name': 'moji', 'age': 21 };\rfor (var i in obj) {\rconsole.log('键名：', i);\rconsole.log('键值：', obj[i]);\r}\r// 键名： name\r// 键值： moji\r// 键名： age\r// 键值： 21\r 关于数组的遍历，以后再总结~\n","date":"2020-11-18","permalink":"https://heeeyueee.github.io/post/js%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/","tags":["JavaScript"],"title":"JavaScript对象基本用法"},{"content":" 浅析JS构造函数与原型~\n 还没有写 https://segmentfault.com/a/1190000006752076\nhttps://segmentfault.com/a/1190000002789651\n","date":"2020-11-18","permalink":"https://heeeyueee.github.io/post/js%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8E%9F%E5%9E%8B/","tags":["JavaScript"],"title":"JS构造对象与原型"},{"content":" 总结JS数据类型中容易混淆的小细节~\n 前话 数据在内存中的位置 数据存在内存的Stack栈区和Heap堆区，Stack栈区中每个数据顺序存放，Heap区中每个数据随机存放。\n数据分为两种：对象和非对象，对象存在Heap堆区，非对象存在Stack栈区。\n字符的存储 字符 JavaScript中字符串是使用类似UTF-8形式存储的（USC-2）。\nUTF-8 是 Unicode 一种存储规则，也叫字符编码规则。Unicode万国码是一种所有符号的编码，可以容纳各个国家的字符，但是每个字符要用三个以上的字节，太耗费空间去存储。UTF-8 是 Unicode 的实现方式之一，UTF-8最少可用8位存一个字符。\n简单数据类型 JavaScript有七种简单数据类型（primitive type）：字符串（string）、数字（number）、布尔值（boolean）、undefined、null（Symbol、BigInt为ES6新增的数据类型），记忆口诀：四基两空两新\nString let a = '你好'\rlet a = \u0026quot;你好,'hello'\u0026quot;\rlet a = `你好\rhello`\r 字符串就是零个或多个排在一起的字符，放在单引号、双引号或反引号之中。单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号。想保留空格和换行使用反引号。\n反斜杠（\\）用来表示一些特殊字符，称为转义符，如\\n 是换行符。\n属性 字符串可以被视为字符数组，所以有length属性，可以使用数组下标来访问某个字符，a[index] ,index的范围0~length-1，a[index]不会报错，会返回undefined。\nNumber  JavaScript中数字是不区分整数值与浮点数值的，在JavaScript中所有的数均使用64位（8字节）的浮点数格式来存储和表示（IEEE 754标准）。所以数值最大是：±1.7976931348623157 X 10^308，最小是±5X10^-324，可以表示的整数范围是-9 007 199 254 740 992 ~ 9 007 199 254 740 992 （对应的是-2^53~2^53）包含边界值。 当任何数字在进行位运算时 js 内部hui将其转换成32位有符号整型。\n 由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。\n 符号占1 位，0表示正数，1表示负数 指数占11 位（-1023 ~1024 ） 有效数字占52 位（ 开头的1省略）  特殊值   正零和负零\n一般情况下都当作0使用，只有+0或-0当作分母，返回的值是不相等的\n  NaN\n表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。但它的数据类型依然属于Number。NaN === NaN // false\n  Infinity\nInfinity表示正的无穷，-Infinity表示负的无穷。\n  Boolean 布尔表示一个逻辑实体，可以有两个值：true 和 false。\nfalsy 一定要记住五个falsy值！！！相当于false但又不是false的值，JS会将falsy值自动转为false，其他值都视为true。\n null undefined 0 NaN ''  Null null是一个表示“空”的对象，转为数值时为0；null 是表示缺少的标识，指示变量未指向任何对象。可以把 null 作为尚未创建的对象。\n 在 API 中，null 常在返回类型应是一个对象，但没有关联的值的地方使用。 作为函数的参数， 表示该函数的参数不是对象。 作为对象原型链的终点  Undefined undefined是一个表示\u0026quot;此处无定义\u0026quot;的原始值，转为数值时为NaN。\n 一个没有被赋值的变量的类型是undefined。如果方法或者是语句中操作的变量没有被赋值，则会返回undefined。 一个函数如果没有使用return语句指定返回值，就会返回一个undefined值。  区别  undefined 是默认的空， null是主动的空 习惯上， 把非对象的空值写为undefined,把对象的空值写为null  Symbol  每个从Symbol()返回的symbol值都是唯一的。一个symbol值能作为对象属性的唯一标识符，防止对象属性冲突发生,这是该数据类型仅有的目的。\n 使用 👉参考博客:JS 中的 Symbol 是什么？\nBigInt  BigInt 可以表示任意大的整数,它提供了一种方法来表示大于 253 - 1 的整数。\n 使用   在一个整数字面量后面加 n 的方式定义一个 BigInt\n  调用函数BigInt()\nconst theBiggestInt = 9007199254740991n;\rconst alsoHuge = BigInt(9007199254740991);\r// ↪ 9007199254740991n\r   复杂数据类型 对象则称为合成类型（complex type）的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。\nObject 👉另外一篇博客中有详细总结:JS对象基本用法\n数据类型转换 字符串转换  显式地调用 String(value) 来将 value 转换为字符串类型 value+\u0026quot;\u0026quot;(加上空字符串)  数字型转换  在算术函数和表达式中，会自动进行 number 类型转换 如:value-0 Number(value) 显式地将这个 value 转换为 number 类型 parseInt(value)和parseFloat(value)将这个 value 转换为 number 类型  布尔型转换  falsy（如 0、空字符串、null、undefined 和 NaN）将变为 false。 其他值变成 true。  注意  undefined转为数值时为NaN，null转为数值时为0 对 \u0026quot;0\u0026quot; 和只有空格的字符串（比如：\u0026quot; \u0026quot;）进行布尔型转换时，输出结果为 true。  数据类型判断 typeof 使用 typeof 数据\r 说明  typeof可以判断基本类型和函数：Number,String,Boolean,Undefined,symbol,BigInt,Function 无法判断Null，会返回Object 无法判断某个对象的具体类型，对于对象除了函数都会返回Object，比如数组类型会直接返回Object  instanceof instanceof操作符判断左操作数对象的原型链上是否有右边这个构造函数的prototype属性，也就是说判定对象是否是某个构造函数的实例，最后返回布尔值。\n使用 let a=[]\ra instanceof Array //true\ra instanceof Object; // true\r 说明  instanceof运算符用于判断对象的具体类型，不能判断7种基本类型的值。 上例可得：a.__proto__ === Array.prototype Array 构造函数是继承自 Object 对象的，因此在 arr 变量上是可以访问到 Object 的 prototype 属性的，Object 构造函数的 prototype 属性存在与 arr 这个数组实例的原型链上，所以a也能判断为Object。  constructor 使用 let a=[]\ra.constructor === Array //true\r 说明   使用constructor判断变量类型的方法，非常高效\n  但是无法检测 null 或者 undefined 类型，null 和 undefined 根本就没有 constructor 属性\n  并且constructor 属性易变，不可信赖，这个主要体现在自定义对象上，当开发者重写prototype后，原有的constructor会丢失。\n**ps：**所以，重写对象原型时一般都需要重新给constructor赋值，以保证实例对象的类型不被改写。\nArray.prototype = {\rconstructor: Array, name: 'moji',\r};\rvar a = new Array();\ra.constructor === Array; // true\r   Object.prototype.toString.call() 使用 Object.prototype.toString.call(null); // \u0026quot;[object Null]\u0026quot;\rObject.prototype.toString.call([]); // \u0026quot;[object Array]\u0026quot;\r 说明 最可靠的方法，赛高✿✿ヽ(°▽°)ノ✿\n参考 判断类型\n学习网站\n阮一峰教程\n","date":"2020-11-17","permalink":"https://heeeyueee.github.io/post/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","tags":["JavaScript"],"title":"JavaScript数据类型"},{"content":" 简单总结一下JavaScript基本语法~\n 表达式和语句   表达式：为了得到返回值的表达式\n  语句：为了完成某种任务而进行的操作。JavaScript程序的执行单位为行，一般情况下每一行就是一个语句，语句以分号;来结尾。\n 两者区别：1.语句一般是为了进行某项操作，会改变环境，不一定有返回值。2.表达式是为了得到返回值，一定会返回一个值。\n   标识符 标识符（identifier）指的是用来识别各种值的合法名称。所有的可以由我们自主命名的都可以称为是标识符，例如:变量名、函数名、属性名都属于标识符。\n标识符命名规范：\n 第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。简单来说，不能以数字开头，可以是中文（不推荐）。 第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9。 标识符不能是关键字和保留字符 标识符一般都采用驼峰命名法  变量 概念 变量是对“值”的具名引用。变量就是为“值”起名，然后引用这个名字，就等同于引用这个值。变量的名字就是变量名。变量名存储内存的不知道什么区，下图展示变量名，变量地址，变量的关系在内存中存储的位置。\n变量声明与赋值 变量声明有三种方式：var、let、const\n  var\nvar声明的变量不遵循块作用域且允许重复声明，容易不知不觉地创建全局变量，不要使用！！！\n var变量提升：\nJavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。\n console.log(a);\rvar a = 1;\r------变量提升作用-----\rvar a;\rconsole.log(a);\ra = 1;\r 实际上不会报错，结果是显示undefined，表示变量a已声明，但还未赋值。\n 👉关与变量提升，更多学习参考博客从本质上理解JavaScript中的变量提升\n   let\n  遵循块作用域， 即使用范围不能超出{ }\n  不能重复申明\n  可以赋值， 也可以不赋值\n  必须先声明再使用， 否则报错\n  全局声明的let 变量， 不会变成window 的属性\n  在for循环中使用let来声明i\n   关与let与for循环，let与块作用域，变量声明的三种方式，变量提升等等还需后续来填坑，小白已在各篇博客中绕晕/(ㄒoㄒ)/~~\n附上博客连接：\n👉从本质上理解JavaScript中的变量提升\n👉我用了两个月的时间才理解 let\n👉for循环中let与var的区别\n   const\n 给const 修饰的标识符被赋值之后， 不能修改 声明变量的时候必须初始化赋值 常量的含义是指向的对象不能修改， 但是可以改变对象内部的属性    条件语句 if 结构 // 第一种\rif (布尔值)\r语句;\r// 第二种\rif (布尔值) {\r语句;\r}\r 第一种写法要求条件表达式后面只能有一个语句。如果想执行多个语句，使用第二种写法，必须在if的条件判断之后，加上大括号，表示代码块（多个语句合并成一个语句）。\nif else 结构 if代码块后面，还可以跟一个else代码块，表示不满足条件时，所要执行的代码。else代码块总是与离自己最近的那个if语句配对。\n推荐写法:\nif (表达式) {\r语句\r} else if (表达式) {\r语句\r} else {\r语句\r}\r switch结构 if else 结构的升级版\nswitch (x) {\rcase 1:\rconsole.log('x 等于1');\rbreak;\rcase 2:\rconsole.log('x 等于2');\rbreak;\rdefault:\rconsole.log('x 等于其他值');\r}\r **注意: **\n 每个case代码块内部的break语句不能少，否则会接下去执行下一个case代码块，而不是跳出switch结构。 switch语句后面的表达式，与case语句后面的表示式比较运行结果时，采用的是严格相等运算符（===），而不是相等运算符（==），这意味着比较时不会发生类型转换。  三元运算符 三元运算符可以被视为if...else...的简写形式，if和else后面都只有一个语句时可以用三元运算符来替代。\n(条件) ? 表达式1 : 表达式2\r \u0026amp;\u0026amp;短路逻辑 A \u0026amp;\u0026amp; B //如果A的值为真值就会执行B操作\r || 短路逻辑 A || B //如果A的值为真值就会取A的值否则取B的值\r 循环语句 循环语句用于重复执行某个操作\nwhile 语句 while (条件)\r语句;\r// 或者\rwhile (条件) 语句;\r while语句的循环条件是一个表达式，必须放在圆括号中。代码块部分，如果只有一条语句，可以省略大括号，否则就必须加上大括号。\nwhile (条件) {\r语句;\r}\r for 循环 for是while循环的方便写法，可以指定循环的起点、终点和终止条件。\nfor (初始化表达式; 条件; 递增表达式)\r语句\r// 或者\rfor (初始化表达式; 条件; 递增表达式) {\r语句\r}\r for语句的三个部分（initialize、test、increment），可以省略任何一个，也可以全部省略。\nbreak与continue break语句和continue语句都具有跳转作用，可以让代码不按既有的顺序执行。\n break语句用于跳出代码块或循环，完全跳出循环。 continue语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。  label 语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。标签通常与break语句和continue语句配合使用，跳出特定的循环。\nfoo: {\rconsole.log(1);\rbreak foo;\rconsole.log('本行不会输出');\r}\rconsole.log(2);\r// 1\r// 2\r 注意  JS大小写敏感，空格和回车没有意义，有一个地方不能加回车（return后），加了return后面会自动补undefined label 面试时会考语法：{ foo:1 }不是一个对象 for循环语句里的条件要使用let来定义判断的i的值 不推荐使用switch，容易忘记写break 不要混淆赋值表达式（=）、严格相等运算符（===）和相等运算符（==）。尤其是赋值表达式不具有比较作用。 优先采用“严格相等运算符”（===），而不是“相等运算符”（==） ","date":"2020-11-16","permalink":"https://heeeyueee.github.io/post/js%E8%AF%AD%E6%B3%95/","tags":["JavaScript"],"title":"JavaScript语法"},{"content":" 轻松小文，看看JavaScript诞生的故事吧~\n 诞生 ​ JavaScript是一种轻量级的脚本语言，它运行在浏览器上依赖于浏览器的宿主环境（Node 环境中也可以），JavaScript通过浏览器提供各种的 API，如window、document等等来编写控制浏览器程序。所以，JavaScript的诞生一定和浏览器有关系ヾ(◍°∇°◍)ﾉﾞ\n 看看维基百科上的介绍——JavaScript的历史\n   1994年，网景公司（Netscape）发布了Navigator浏览器0.9版。这是历史上第一个比较成熟的网络浏览器，轰动一时。但是，这个版本的浏览器只能用来浏览，不具备与访问者互动的能力。因此，网景公司急需一种网页脚本语言，使得浏览器可以与网页互动。\n  网景公司任命工程师Brendan Eich来负责开发这种新语言。网景公司和Java的母公司Sun想设计一种**\u0026ldquo;看上去与Java足够相似，但是比Java简单“**的脚本语言，但当时他觉得，没必要设计得很复杂，这种语言只要能够完成一些简单操作就够了。所以，Brendan Eich只花了十天就把JavaScript设计出来了，成为了JavaScript之父。\n  发展 ​ 虽然JavaScript推出后在浏览器上大获成功，但JavaScript的发展道路充满了艰辛，由于设计时间太短，语言的一些细节考虑得不够严谨，导致后来很长一段时间，Javascript写出来的程序混乱不堪。\n  微软公司在不久后就模仿JavaScript为自家的IE 3浏览器推出了JScript，以与处于市场领导地位的网景产品同台竞争。，发展初期，JavaScript的标准并未确定，网景的JavaScript与微软的JScript双峰并峙。\n  1996年11月，网景公司开始反击，网景正式向ECMA（欧洲计算机制造商协会）提交语言标准。1997年6月，ECMA以JavaScript语言为基础制定了ECMAScript标准规范ECMA-262。市场份额成为了ECMAScript最著名的实现之一。\n  1996年至2006年，随着windows操作系统的推广，IE浏览器的被广泛使用，成为了市场份额最大的浏览器，微软公司对浏览器功能的完善改进十分懈怠，这也导致了JavaScript发展的停滞。\n  2008年，谷歌公司的chrome浏览器面世，不到三年市场份额就超过了Firefox，2016年市场份额达到了62%，打败了停滞不前的IE浏览器。同时，移动智能终端也在迅速发展，苹果公司的平板电脑、智能手机等等都带动了浏览器和JavaScript的发展应用。\n  2009年诞生的node.js让JavaScript多了一个宿主环境，让JavaScript不止是在浏览器上运行，让JavaScript有了更广阔的前景~\n  参考 维基百科\n阮一峰——Javascript诞生记\nJavascript继承机制的设计思想\nJavascript的10个设计缺陷\n","date":"2020-11-13","permalink":"https://heeeyueee.github.io/post/javascript-%E7%9A%84%E8%AF%9E%E7%94%9F/","tags":["JavaScript"],"title":"JavaScript的诞生"},{"content":" HTTP请求与HTTP响应详解\n HTTP请求完整步骤 先简单的使用curl命令来发出请求，在命令行观察一次HTT请求和响应的步骤~\n  DNS域名解析\n在上一篇《浅析URL》中已经学习了解了DNS域名系统，这一步就是将域名解析成对应的服务器IP地址\n  建立TCP连接\nTCP 位于传输层，提供可靠的字节流服务。字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。简单来说，TCP协议为了更容易传输大数据将其切割，并且还能确认数据完整无误的传送给了对方。\nTCP采用三次握手策略来保证数据传输的可靠性。握手过程中使用了 TCP 的标志 —— SYN（synchronize） 和 ACK（acknowledgement），下图是TCP三次握手的图解：（来自于《HTTP图解》）\n  发送HTTP请求\n通过TCP协议与服务器建立连之后，就可以向服务器发起请求了~客户端发出请求报文，请求报文包含报文首部、空行和报文主体。其中，最重要的就是报文首部！报文首部中的请求行包括请求方法、用于定位资源的URI、HTTP版本。首部字段传递重要信息，包括请求首部字段、通用首部字段和实体首部字段。\n   服务器处理请求\nHTTP服务器接收到请求报文后，就会开始解析报文，分析客户端想要获取到的资源，然后开始调度服务器资源来响应客户端的请求。\n  返回响应结果\n服务器发出响应报文来响应请求，响应和请求报文的结构相似，包含报文首部、空行和报文主体。报文首部中的状态行包含表明响应结果的状态码，原因短语和 HTTP 版本。首部字段，包括响应首部字段、通用首部字段和实体首部字段。\n  关闭TCP连接\n为了避免服务器与客户端双方的资源占用和损耗，当双方没有请求或响应传递时，任意一方都可以发起关闭请求。与创建TCP连接的3次握手类似，关闭TCP连接，需要4次握手。\nNOW，借用HTTP图解中的图来回顾以下\n  HTTP请求报文  题外话：看了《HTTP图解》后，其中的报文首部、报文主体和我们常说的请求行、请求头、请求体、状态行、响应头、响应体有点混淆，用一个表格来对应他们的关系吧~\n  在《HTTP图解》中，对请求报文的各个部分都有详细的解读，本人详见印象笔记的记录，本博客只对重要常用的点做出记录。\n 请求行 包含用于请求的方法，请求 URI 和 HTTP 版本\nGET / HTTP/1.1\r   请求的方法\nHTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。 HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。\nAttention: 方法名称是区分大小写的，当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Mothod Not Allowed）；当服务器不认识或者不支持对应的请求方法时，应返回状态码501（Not Implemented）。\n  请求头 请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔，key:value。\n请求头部通知服务器有关于客户端请求的信息，典型的请求头有：\n   请求头 说明     Content-Type 是返回消息中非常重要的内容，表示后面的文档属于什么MIME类型。   Host 指定请求资源的Intenet主机和端口号，必须表示请求url的原始服务器或网关的位置。   Accept 浏览器可接受的MIME类型   User-Agent 用户代理，浏览器类型   Connection 表示是否需要持久连接    补充 :\n常见的MIME类型如下:\n text/html ： HTML格式 text/plain ：纯文本格式  text/xml ： XML格式 image/gif：gif图片格式 image/jpeg ：jpg图片格式  image/png：png图片格式  以application开头的媒体格式类型：\n application/xhtml+xml ：XHTML格式 application/xml ： XML数据格式 application/atom+xml：Atom XML聚合格式 application/json ： JSON数据格式 application/pdf ：pdf格式 application/msword ： Word文档格式 application/octet-stream： 二进制流数据（如常见的文件下载） application/x-www-form-urlencoded ： 中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）  另外一种常见的媒体格式是上传文件之时使用的：\n multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式  空行 最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。\n请求体 请求数据不在GET方法中使用，而是在POST方法中使用，POST的数据就放在请求体中。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。\nHTTP响应报文 状态行 由协议版本、数字形式的状态代码、及相应的状态描述，各元素之间以空格分隔\nHTTP/1.1 200 OK  HTTP状态码：图片来自与网络\n面试时常考304，详见博客：304\n响应头 和请求头相似，由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔，key:value。常见的响应头:\n   响应头 说明     Location Location响应报头域用于重定向接受者到一个新的位置   Server Server响应报头域包含了服务器用来处理请求的软件信息,它和User-Agent请求报头域是相对应的   WWW-Authenticate WWW-Authenticate响应报头域必须被包含在*401(未授权的)*响应消息中   Content-Type Content-Type实体报头域用语指明发送给接收者的实体正文的媒体类型   Last-Modified Last-Modified实体报头域用于指示资源最后的修改日期及时间    空行 发送回车符和换行符，通知客户端以下不再有响应头。\n响应体 响应体就是服务器返回的数据，如HTML页面，json数据等等。\n阿里云服务器部署   在github上新建repo上传Node.js代码。\n  在xshell远程连接阿里云服务器并新建用户\nadduser -m hy //新建用户\rpasswd hy\r   登录新用户\nssh hy@1XX.92.1XX.XX\r   在centos中安装node和git（使用sudo来给hy用户安装权限）\n参考博客如何在CentOS上安装Node.js？超简单！3分钟搞定。\n​ centos上安装git服务\n  把github上的node.js代码下载到服务器\ngit clone https://github.com/heeeyueee/nodedemo.git\r   部署应用\ncd nodedemo\rtouch log\r启动命令：node server.js 8888 \u0026gt; log 2\u0026gt;\u0026amp;1 \u0026amp;\r把启动命令做成 start 文件\r添加执行权限 chmod +x ./start\r运行 sh ./start 得到一个进程号 pid\rtail log 看 log 内容\rkill -9 pid 可以关掉进程\rkillall node 可以关掉所有 node 进程\r   重启应用\nssh hy@实例ip\rcd nodedemo\rgit pull\rkillall node\rsh ./start\r  ","date":"2020-11-12","permalink":"https://heeeyueee.github.io/post/http%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/","tags":["HTTP"],"title":"HTTP请求与响应"},{"content":" URL组成,IP,域名,DNS\n URL组成 ​ 统一资源定位符（Uniform Resource Locator，缩写：URL；俗称网页地址或简称网址）是因特网上标准的资源的地址（Address），如同在网络上的门牌。它最初是由蒂姆·伯纳斯-李发明用来作为万维网的地址\n​ URL= 协议+ 域名或IP + 端口号+ 路径+ 查询字符串+ 锚点\n 完整格式 ：\n    内容 说明     传送协议  HTTP  HTTPS  FTP   层级URL标记符号 为[//],固定不变   访问资源需要的凭证信息 可省略   服务器 通常为域名，有时为IP地址，   端口号 端口定位设备的服务，以数字方式表示，若为默认值可省略   路径 以“/”字符区别路径中的每一个目录名称，用来请求不同页面的资源   查询 GET请求的窗体参数，以“?”字符为起点，每个参数以“\u0026amp;”隔开，通常以UTF8的URL编码，避开字符冲突   片段 以“#”字符为起点，定位页面上内容的位置，不支持中文    IP  IP地址（全称Internet Protocol Address），译为网际协议地址、互联网协议地址。当设备连接网络，设备将被分配一个IP地址，用作标识。通过IP地址，设备间可以互相通讯。 IP地址有两个主要功能：标识设备或网络 和 寻址。\n 公有IP地址与私有IP地址 ​ 平时我们办公室、家里、学校用的 IP 地址，一般都是私有 IP 地址（由网关给设备分配的）。因为这些地址允许组织内部的 IT 人员自己管理、自己分配，而且可以重复。然后通过电信运营商分配给网关的公有IP地址来访问外网，公有 IP 地址基本上要在整个互联网范围内保持唯一。 外网不能访问内网，外网先把内容加载到网关设备 ，内网在访问网关设备来获取内容\n网关  路由器就是网关设备\n 功能 1.路由：收集网络拓扑信息并动态形成路由表\n2.转发：根据路由表转发IP数据包\n3.隔离广播域\n4.将不同网段上的设备进行互通\n5.子网间速率适配\n6.指定访问规则\n常用功能——现在路由器有两个IP, 一个外网IP 和一个内网IP内网中的设备可以互相访问， 但是不能直接访问外网内网设备想要访问外网， 就必须经过路由器中转。\nping命令 在网络中ping是一个十分强大的TCP/IP工具。它的作用主要为：\n 用来检测网络的连通情况和分析网络速度 根据域名得到服务器IP 根据ping返回的TTL值来判断对方所使用的操作系统及数据包经过路由器数量。  我们通常会用它来直接ping ip地址，来测试网络的连通情况。\n举例\n域名  网域名称（英语：Domain Name），简称域名、网域，是由一串用点分隔的字符组成的互联网上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位。域名可以说是一个IP地址的代称，目的是为了便于记忆后者。\n   www.baidu.com与baidu.com不是同一个域名，com 是顶级域名，baidu.com 是二级域名（ 俗称一级域名）www.baidu.com 是三级域名（ 俗称二级）。\n  一个域名可以对应不同IP——均衡负载\n  一个IP也可以对应多个不同的主机——叫做共享主机\n  了解完域名和IP的概念，再来看看将IP和域名对应起来的DNS域名系统~\nDNS  DNS，英文全写为Domain Name System，中文意思为域名系统，是互联网中提供域名与IP地址互相映射的分布式数据库。\n 简单来说，域名系统 (DNS) 将人类可读的域名 (例如，www.amazon.com) 转换为机器可读的 IP 地址 (例如，192.0.2.44)。\nnslookup 命令 nslookup命令用于查询DNS的记录，查看域名解析是否正常，在网络故障的时候用来诊断网络问题。\n使用\nnslookup domain [dns-server]\r 举例\n参考 IP知识图解\n","date":"2020-11-10","permalink":"https://heeeyueee.github.io/post/%E6%B5%85%E6%9E%90url/","tags":["HTTP"],"title":"浅析URL"},{"content":" 浏览器渲染流程,transform,transition,animation\n 浏览器渲染 原理  浏览器的工作原理：\n 浏览器输入URL后发生了什么\nMDN浏览器渲染页面的工作原理\n流程 关键渲染路径\n关键渲染路径是指浏览器从最初接收请求来的HTML、CSS、javascript等资源，然后解析、构建树、渲染布局、绘制，最后呈现给客户能看到的界面这整个过程。\n 根据HTML 构建HTML 树(DOM) 根据CSS 构建CSS 树(CSSOM) 将两棵树合并成一颗渲染树(rendertree) Layout 布局（ 文档流、盒模型、计算大小和位置） Paint 绘制（ 把边框颜色、文字颜色、阴影等画出来） Compose 合成（ 根据层叠关系展示画面）  三种更新样式的方式\n  JS / CSS \u0026gt; 样式 \u0026gt; 布局 \u0026gt; 绘制 \u0026gt; 合成（全走）\n修改元素的“layout”属性，也就是改变了元素的几何属性（例如宽度、高度、左侧或顶部位置等），那么浏览器将必须检查所有其他元素，然后“自动重排”页面。如：div.remove()\n  JS / CSS \u0026gt; 样式 \u0026gt; 绘制 \u0026gt; 合成\n修改“paint only”属性（例如背景图片、文字颜色或阴影等），即不会影响页面布局的属性，浏览器会跳过布局，但仍将执行绘制。\n   JS / CSS \u0026gt; 样式 \u0026gt; 合成\n更改一个既不要布局也不要绘制的属性，则浏览器将跳到只执行合成，如改变transform属性。\n  渲染性能优化 ​ 这是一个像素管道，JavaScript（代码变动）、Style（样式计算）、Layout（布局计算）、Paint（绘制）、Composite（合成）是像素绘制到屏幕上的五个关键点，分别针对每一部分进行渲染性能优化，让动画和交互应如丝绸般顺滑。\n1.JavaScript\n 对于动画效果的实现，避免使用 setTimeout 或 setInterval，请使用 requestAnimationFrame。 将长时间运行的 JavaScript 从主线程移到 Web Worker。 使用微任务来执行对多个帧的 DOM 更改。 使用 Chrome DevTools 的 Timeline 和 JavaScript 分析器来评估 JavaScript 的影响。  2.Style\n 降低选择器的复杂性；使用以类为中心的方法，例如 BEM。 减少必须计算其样式的元素数量。  3.Layout\n 尽可能避免布局操作 使用 flexbox 而不是浮动布局 避免强制同步布局 避免布局抖动  4.Paint\n 除 transform 或 opacity 属性之外，更改任何属性始终都会触发绘制。 绘制通常是像素管道中开销最大的部分；应尽可能避免绘制。 通过层的提升和动画的编排来减少绘制区域。 使用 Chrome DevTools 绘制分析器来评估绘制的复杂性和开销；应尽可能降低复杂性并减少开销。  5.Composite\n 坚持使用 transform 和 opacity 属性更改来实现动画。 使用 will-change 或 translateZ 提升移动的元素。 z-index 层数过多会占用更多的内存，请合理分配   详见google文章渲染性能优化\n transform 转换 功能 transform 转换来实现 2D 转换或者 3D 转换。inline 元素不支持transform ， 需要先变成block。\n使用  介绍常用的2D变换功能\n   位移：translate\ntransform: translate(水平位移, 垂直位移);\rtransform: translate(-50%, -50%);\r   参数为百分比，相对于自身移动。\n  实现绝对定位元素的居中\n{ position:absolute;\rleft:50%;\rtop:50%;\rtransform:translate(-50%,-50%); }\r     缩放：scale\ntransform: scale(x, y);\rtransform: scale(2, 0.5);\r 参数解释： x：表示水平方向的缩放倍数。y：表示垂直方向的缩放倍数。如果只写一个值就是等比例缩放。\n取值：大于1表示放大，小于1表示缩小。不能为百分比。\n  旋转：rotate\ntransform: rotate(角度);\rtransform: rotate(45deg);\r 参数解释：正值 顺时针；负值：逆时针。\n  倾斜：skew\ntransform:skew(x,y);\r 参数解释：第一个参数对应X轴倾斜的度数，第二个参数对应Y轴倾斜的度数 , 单位为deg。\n  transition 过渡 transition的中文含义是过渡。过渡是CSS3中具有颠覆性的一个特征，可以实现元素不同状态间的平滑过渡（补间动画），经常用来制作动画效果。\n属性    属性 值     transition-property 要过渡的属性名 all代表所有属性   transition-duration 过渡的持续时间   transition-timing-function 运动曲线 linear 线性 |ease 减速|ease 减速|ease-out 减速|ease-out 减速   transition-delay 过渡延迟    使用 transition: 让哪些属性进行过度 过渡的持续时间 运动曲线 延迟时间;\rtransition: all 3s linear 0s;\r  不是所有属性都能过渡 display:none\u0026lt;==\u0026gt;block无法过渡 visibility：hidden\u0026lt;==\u0026gt;visible可以过渡  animation 动画 keyframes keyframes关键字用来定义动画的各个状态\n有两种写法 : 1.from to 写法 2.百分数写法\n@keyframes 动画名{\rfrom{ 初始状态 }\rto{ 结束状态 }\r}\r @keyframes rainbow {\r0% { background: #c00 }\r50% { background: orange }\r100% { background: yellowgreen }\r}\r 属性 animation: 时长 | 过渡方式 | 延迟 | 次数 | 方向 | 填充模式 | 是否暂停 | 动画名\ranimation: move1 1s alternate linear 3;\ranimation: move2 4s;\r    属性 值     执行次数 infinite   方向 reverse| alternate| alternate-reverse   填充模式（设置动画结束时，盒子的状态） none | forwards | backwards | both   是否暂停 paused | running   过渡方式 和transition的取值一样    使用步骤 （1）通过@keyframes定义动画；\n（2）将这段动画通过百分比，分割成多个节点；然后各节点中分别定义各属性；\n（3）在指定元素里，通过 animation 属性调用动画。\n实践 CSS动画——爱心\n参考博客 google渲染树构建、布局及绘制\n十分钟读懂浏览器渲染流程\ngoogle渲染性能\n性能优化之关于像素管道\n前端性能优化 24 条建议\nCSS3动画详解（图文教程）\nCSS动画\n","date":"2020-11-09","permalink":"https://heeeyueee.github.io/post/css%E5%8A%A8%E7%94%BB/","tags":["CSS"],"title":"CSS动画"},{"content":" 图解line-height的使用\n line-height是什么 line-height属性用于设置行间的距离（行高），行高指的是字母的大小(font-size)和字母的上下边缘(字母大小 + 上下空白)。\n所以，文本单行占据的高度不是font-size来决定的，而是由line-height来决定的。\nline-height的写法 关键词 line-height: normal;\r 取决于用户端。桌面浏览器（包括Firefox）使用默认值，约为1.2，这取决于元素的 font-family。\n长度px、em \u0026lt;p\u0026gt;udemy\u0026lt;/p\u0026gt;\rp{\rfont-size:20px;\rline-height:30px;\r}\r 字母的大小(font-size)是20 px，line- height 是30 px，上下留白为5px。\n数字 \u0026lt;p\u0026gt;udemy\u0026lt;/p\u0026gt;\rp{\rfont-size:20px;\rline-height:2;\r}\r line- height 为font-size: 20 px 的2倍（20 × 2= 40 px），字母的大小(font-size)是20 px，上下留白为10px。\n百分比 \u0026lt;p\u0026gt;udemy\u0026lt;/p\u0026gt;\rp{\rfont-size:20px;\rline-height:200%;\r}\r line- height 为 font-size: 20 px 的200% ，为40 px，同样上下留白为10px。。\nPS：line-height可继承，给元素设置line-height会对其内部所有的孩子都生效\n","date":"2020-11-09","permalink":"https://heeeyueee.github.io/post/css%E4%B9%8Bline-height%E7%9A%84%E4%BD%BF%E7%94%A8/","tags":["CSS"],"title":"图解line-height的使用"},{"content":" CSS的position属性,z-index的管理,层叠上下文\n  CSS 有两个最重要的基本属性：display 和 position。\ndisplay属性指定网页的布局。position属性指定网页的定位。\n布局是屏幕平面上的，定位是垂直于屏幕上的。\n 阅读之前要弄懂文档流和盒模型的概念 点击回顾\nposition属性  不管是哪种定位，都必须有一个参照物。找对了参照物，就成功了一半。\n static ​ static是position属性的默认值。如果省略position属性，浏览器就认为该元素是static定位。浏览器会按照源码的顺序，决定每个元素的位置，这称为\u0026quot;正常的页面流\u0026quot;（normal flow）。每个块级元素占据自己的区块（block），元素与元素之间不产生重叠，这个位置就是元素的默认位置。top、bottom、left、right这四个属性无效。\n static是非定位元素  relative ​ relative表示，相对的是元素本身应该出现的位置（即static时的位置）进行偏移。\n注意：\n 给absolute元素做父元素 配合z-index创建层叠上下文（不为auto） 不会脱离文档流，本应该占的位置还会保留，下一个元素不能忽视它的存在。  absolute ​ absolute相对于祖先元素中最近的一个定位元素（position非static）进行偏移，否则定位基点就会变成整个网页的根元素html。要写上top 、left属性值。\n注意：\n 脱离原来的位置，另起一层，如对话框的关闭按钮 善于用百分数，left:50% ;left:100% 会脱离文档流  fixed ​ fixed表示，相对于视口（viewport，浏览器窗口）进行偏移，即定位基点是浏览器窗口。\n注意：\n 常用于烦人的广告和回到顶部按钮 当祖先元素具有transform属性且不为none时，就会相对于祖先元素指定坐标，而不是浏览器窗口。（失效） 移动端不要使用这个属性（坑多）  sticky ​ 能够形成\u0026quot;动态固定\u0026quot;的效果，如导航栏，但是很多浏览器上还不支持此属性（简单了解）\nz-index 取值  关键字 ：auto 数值： 任意整数（包括正数、负数、0）  作用   z-index的默认值是auto, 不建立新的层叠上下文\n  当z-index取数值时，有两个作用：\n① 在当前元素建立一个堆叠上下文，即告诉浏览器这里出现了堆叠，需要考虑分层了。\n② 告诉浏览器当前元素在这个堆叠上下文中所占的位置\n  使用  只有position为relative/absolute/fixed的元素，z-index属性才起作用。注意，是该元素本身。 z-index遵循从父原则，即如果父元素和子元素同时设置了z-index,以父元素的z-index为准。 博客参考最佳实践 -1，0，1，2足够 负z-index逃不出层叠上下文  层叠上下文  不同的 DOM 元素组合在一起发生重叠的时候，它们的的显示顺序会遵循层叠水平的规则，而 z-index 是用来调整某个元素显示顺序，使该元素能够上浮下沉。\n 规则 那么当两个元素层叠水平相同的时候，这时候就要遵循下面两个准则：\n 后来居上原则 谁 z-index 大，谁在上的准则（同一个层叠上下文中）  那么当两个元素在不同的层叠上下文中时候：\n 先找到共同的祖先层叠上下文，然后比较共同层叠上下文下这个两个元素所在的局部层叠上下文的层叠水平 处在层叠上下文中的元素和处在这个上下文外的元素无关（z-index无法比较） 处在同一个层叠上下文中的元素的z-index才能比较  创建 ​ 一个页面中往往不仅仅只有一个层叠上下文，在一个层叠上下文内，我们按照层叠水平的规则来堆叠元素。，一些不正交的属性可以创建一个层叠上下文（小世界）。\n  默认创建层叠上下文\nHTML 根元素\n  需要配合 z-index 触发创建层叠上下文\n position 值为 absolute（绝对定位）或 relative（相对定位）且 z-index 值不为 auto 的元素 flex (flexbox) 容器的子元素，且 z-index 值不为 auto； grid (grid) 容器的子元素，且 z-index 值不为 auto；    不需要配合 z-index 触发创建层叠上下文\n opacity 属性值小于 1 的元素 position 值为 fixed（固定定位）或 sticky（粘滞定位）的元素 \u0026hellip;\u0026hellip;..    详见MDN文档\n参考文档 阮一峰css定位详解\n深入了解z-index的用法\n深入理解 CSS 属性 z-index\nMDN层叠上下文\nCSS定位属性详解\n","date":"2020-11-09","permalink":"https://heeeyueee.github.io/post/css%E5%AE%9A%E4%BD%8D/","tags":["CSS"],"title":"CSS定位"},{"content":" 学习目前流动使用的三种布局: float flex grid\n float布局  float CSS属性指定一个元素应沿其容器的左侧或右侧放置，允许文本和内联元素环绕它。该元素从网页的正常流动(文档流)中移除，尽管仍然保持部分的流动性（与绝对定位相反）。 —— MDN*\n  float布局的缺陷（引发的问题）:浮动高度塌陷  如果浮动元素的父元素没有设定高度，当其子元素浮动后，父元素就因为内部没有子元素撑起从而高度变为0；\n 引申：网页元素一般分为 普通流，浮动流，定位流。其中普通流和浮动流在一个层级上，定位流\u0026gt;浮动流\u0026gt;普通流。\n 解决: 在子元素上加上float和width,在父元素上加上.clearfix\n.clearfix:after{\rcontent: '';\rdisplay: block;\rclear: both;\r}\r   使用经验\n  最后一个元素不设长度或设置一个最大的长度\n  float布局是专门为IE浏览器做准备的，不需要做响应式的\n  平均布局中使用负margin\n  块级元素水平居中：margin：0 auto；最好=\u0026gt;margin-left：auto；margin-right：auto；\n    flex布局  文档中采用 Flex 布局的元素，称为 Flex 容器（flex container）。把一个容器的 display 属性值改为 flex 或者 inline-flex，容器中的直系子元素就会变为 Flex 元素，称为 Flex 项目（flex item）。\n Flex 容器上的属性   display\n.container {\rdisplay: flex; /* or inline-flex */\r}\r   flex-direction 决定主轴的方向\n.container {\rflex-direction: row | row-reverse | column | column-reverse;\r}\r   flex-wrap 定义元素如何换行\n.container {\rflex-wrap: nowrap | wrap | wrap-reverse;\r}\r   flex-flow : flex-direction flex-wrap;是flex-direction,flex-wrap的简写\n.container {\rflex-flow: column wrap;\r}\r   justify-content 定义了项目在主轴上的对齐方式（图片来源于https://css-tricks.com/）\n.container {\rjustify-content: flex-start | flex-end | center | space-between | space-around | space-evenly ;\r}\r   align-items 定义项目在交叉轴上如何对齐（图片来源于https://css-tricks.com/）\n.container {\ralign-items: stretch | flex-start | flex-end | center | baseline ;\r}\r   align-content 属性定义了多根轴线的对齐方式\n.container {\ralign-content: flex-start | flex-end | center | space-between | space-around | space-evenly | stretch;\r}\r   Flex 元素上的属性   order 定义项目的排列顺序。数值越小，排列越靠前，默认为0。\n.item {\rorder: 5; /* default is 0 */\r}\r   flex-grow 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\n.item {\rflex-grow: 4; /* default 0 */\r}\r   flex-shrink 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n.item {\rflex-shrink: 3; /* default 1 */\r}\r   align-self 允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。\n.item {\ralign-self: auto | flex-start | flex-end | center | baseline | stretch;\r}\r   flex 是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。\n该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。\n.item {\rflex: none | [ \u0026lt;'flex-grow'\u0026gt; \u0026lt;'flex-shrink'\u0026gt;? || \u0026lt;'flex-basis'\u0026gt; ]\r}\r   grid布局  和flex布局相似，采用网格布局的区域，称为\u0026quot;容器\u0026quot;（container）。容器内部采用网格定位的子元素，称为\u0026quot;项目\u0026quot;（item）。\n grid容器上的属性   display\n.container {\rdisplay: grid | inline-grid;\r}\r   grid-template-columns grid-template-rows\ngrid-template-columns属性定义每一列的列宽，grid-template-rows属性定义每一行的行高\n.container {\rgrid-template-columns: 40px 50px auto 50px 40px;\rgrid-template-rows: 25% 100px auto;\r}\r  使用repeat()函数简化重复值 repeat(3, 100px);\n使用fr关键字（fraction 的缩写，意为\u0026quot;片段\u0026quot;）。如果两列的宽度分别为1fr和2fr，就表示后者是前者的两倍。可以与绝对长度的单位结合使用\nauto关键字表示由浏览器自己决定长度。\n   grid-template-areas\n网格布局允许指定\u0026quot;区域\u0026quot;（area），一个区域由单个或多个单元格组成。grid-template-areas属性用于定义区域。如果某些区域不需要利用，则使用\u0026quot;点\u0026quot;（.）表示。\n.container {\rdisplay: grid;\rgrid-template-columns: 50px 50px 50px 50px;\rgrid-template-rows: auto;\rgrid-template-areas: \u0026quot;header header header header\u0026quot;\r\u0026quot;main main . sidebar\u0026quot;\r\u0026quot;footer footer footer footer\u0026quot;;\r}\r   grid-template\ngrid-template属性是grid-template-columns、grid-template-rows和grid-template-areas这三个属性的合并简写形式。\n  grid-gap\ngrid-row-gap属性设置行与行的间隔（行间距），grid-column-gap属性设置列与列的间隔（列间距）。grid-gap属性是grid-column-gap和grid-row-gap的合并简写形式。\n  grid元素上的属性   grid-column-start | grid-column-end | grid-row-start | grid-row-end\n项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。（图片来源于https://css-tricks.com/）\n  grid-column 属性，grid-row 属性\ngrid-column属性是grid-column-start和grid-column-end的合并简写形式，grid-row属性是grid-row-start属性和grid-row-end的合并简写形式。\n.item {\rgrid-column: \u0026lt;start-line\u0026gt; / \u0026lt;end-line\u0026gt;;\rgrid-row: \u0026lt;start-line\u0026gt; / \u0026lt;end-line\u0026gt;;\r}\r​```p\r   grid-area\ngrid-area属性指定项目放在哪一个区域，与grid-template-areas属性中分配的区域结合。\n.item-a {\rgrid-area: header;\r}\r   参考博客 flex 阮一峰\nflex tricks\ngrid tricks\ngrid 阮一峰\n","date":"2020-11-08","permalink":"https://heeeyueee.github.io/post/css%E5%B8%83%E5%B1%80/","tags":["CSS"],"title":"CSS布局"},{"content":"CSS语法 语法一:样式语法 选择器 {\r属性名: 属性值;\r/*注释*/\r}\r  所有符号都是英文符号，如果写错了，浏览器会警告 区分大小写，a 和 A 是不同的东西 没有 // 注释 最后一个分号可以省略，但建议不要省略  语法二:at 语法 @charset \u0026quot;UTF-8\u0026quot;;\r@import url(2.css);\r@media (min-width: 100px) and (max-width: 200px) {\r语法一\r}\r  @charset, 定义样式表使用的字符集，但 UTF-8 是字符编码 encoding，@charset 必须放在第一行 @import, 告诉 CSS 引擎引入一个外部样式表 @media, 如果满足媒介查询的条件则条件规则组里的规则生效 前两个 at 语法必须以分号 ; 结尾  文档流和文本流 文本流 Text flow 文本流是元素内部的一系列的字符的排列规则，简单来说是文档的读取和输出顺序，也就是我们通常看到的由左到右、由上而下的读取和输出形式，在网页中每个元素都是按照这个顺序进行排序和显示的，是单纯的相对于文字段落来说的，与容纳文字的元素无关。\n文档流 normal flow 文档流,英文是normal flow,又翻译为常规流,标准流,正常流,普通流等。\n文档流指的是HTML中元素在计算布局排版的过程中,所有处于文档流中的元素会自动的从左到右(非块级元素),从上到下(块级元素)的排列规则。\n脱离文档流与脱离文本流   使用浮动(float)\n  使用绝对定位(position:absolute/fixed)\n区别   浮动会使元素脱离文档流（其他块级元素计算高度时会忽略浮动元素）,但是不会脱离文本流,在于其他盒子的文本内容计算布局的时候,还是占位置的。\n  绝对定位会使元素脱离文档流,同时也会脱离文本流, 在于其他盒子的文本内容计算布局的时候,不占位置。\n      块级元素，内联元素和行块元素 三者转换 可以通过CSS设置display属性来转换display：block、inline、inline-block。inline 元素从左到右，到达最右边才会换行 block 元素从上到下，每一个都另起一行。inline-block 也是从左到右。\n宽度   inline 宽度为内部 inline 元素的和，不能用 width 指定\n  block 默认自动计算宽度，可用 width 指定\n  inline-block 结合前两者特点，可用 width\n  高度   inline 高度由 line-height 间接确定（与字体相关），跟 height 无关\n  block 高度由包裹的文档流元素决定 ,可以设 height,没有元素为0，文档流元素的高度由行高line-height决定.\n  inline-block 跟 block 类似，可以设置 height\n  CSS盒模型 概念 外边距——\u0026gt; 边框——\u0026gt; 内边距——\u0026gt;内容区\nCSS盒模型作用于可以放入内容的块级盒子，如div、span等等。一般使用border-box\n元素 CSS盒子包含以下5个元素：width、height、padding、border、margin。\n  margin与padding区别\n一般使用margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。margin用于布局分开元素使元素与元素互不相干；padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段“距离”。\n  标准盒模型（content-box ）替代（IE）的盒模型（border-box）   标准盒模型（content-box ）content-box width = 内容宽度\n  border-box width = 内容宽度 + padding + border（background是border外边沿包围的区域）\n  ​\noverflow 溢出 等内容的宽度或高度大于容器的，会溢出,可用 overflow 来设置是否显示滚动条\n  auto 是灵活设置\n  scroll 是永远显示\n  hidden 是直接隐藏溢出部分\n  visible 是直接显示溢出部分\n  overflow 可以分为 overflow-x 和 overflow-y\n  margin 合并 父子 margin 合并,兄弟 margin 合并 阻止合并  父子合并用 padding / border 挡住 父子合并用 overflow: hidden 挡住 兄弟合并可以用 inline-block 消除  更多参考：CSS margin合并问题 基本单位 颜色    颜色值 说明     十六进制RGB值 #02798b   RGB值 rgb(2, 121, 139)   RGBA值 rgba(2, 121, 139, .3透明度)   HSL值 hsl(188色调, 97%饱和度, 28%亮度)   HSLA 值 hsla(188, 97%, 28%, .3透明度)    长度单位    长度单位 说明     px 像素   em 在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小   rem 根元素的字体大小   vw 视窗宽度的1%   vh 视窗高度的1%   百分数 相对于其他值设置的     参考博客 HTML中的文档流和文本流\nCSS盒模型\nCSS margin合并问题\n","date":"2020-11-08","permalink":"https://heeeyueee.github.io/post/css%E5%9F%BA%E7%A1%80/","tags":["CSS"],"title":"CSS基础"},{"content":" 复习HTML\n 定义和用法 DOCTYPE翻译过来就是文档类型的意思，向 HTML 文档添加\u0026lt;!DOCTYPE\u0026gt;声明，告知浏览器响应的文档类型。\n\u0026lt;!DOCTYPE\u0026gt; 声明必须是 HTML 文档的第一行，位于\u0026lt;html\u0026gt;标签之前。\n\u0026lt;!DOCTYPE\u0026gt; 声明不是 HTML 标签；它是指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令。\n浏览器的标准模式与怪异模式 来由 微软发布IE5时，未遵循W3C标准。在发布IE6时既想遵循标准，又想老的兼容IE5的页面能在IE6下能正常展示，于是给IE6加入“怪异模式”和“标准模式”两种渲染方式。在标准模式下，浏览器按照HTML与CSS标准（W3C)对文档进行解析和渲染；而在怪异模式下，浏览器则按照旧有的非标准的实现方式对文档进行解析和渲染。这样的话，对于旧有的网页，浏览器启动怪异模式，就能够使得旧网页正常显示；对于新的网页，则可以启动标准模式，使得新网页能够使用HTML与CSS的标准特性。\nHTML 4.01 在 HTML 4.01 中有三种 \u0026lt;!DOCTYPE\u0026gt; 声明——Strict，Transitional， Frameset。\n对于HTML 4.01，默认是“怪异模式”；对于新页面需要在页面顶部加以下指令（Strict）告诉浏览器使用“标准模式”。\n\u0026lt;!DOCTYPE HTML PUBLIC \u0026quot;-//W3C//DTD HTML 4.01//EN\u0026quot; \u0026quot;http://www.w3.org/TR/html4/strict.dtd\u0026quot;\u0026gt;\r HTML5 在HTML5规范里，对DOCTYPE声明做了简化，变成\u0026lt;!DOCTYPE html\u0026gt;告知浏览器当前页面使用的是HTML5规范，并且使用告诉浏览器使用“标准模式”。\n\u0026lt;!DOCTYPE html\u0026gt;\r 对于没有文档类型声明或者文档类型声明不正确的文档，浏览器就会认为它是一个旧的HTML文档，就会使用怪异模式解析和渲染该文档。\n两个模式的区别 盒模型的处理差异：\n标准CSS盒模型的宽度和高度等于内容区的高度和宽度，不包含内边距和边框，是标准盒模型（content-box ）\n而IE6之前的浏览器实现的盒模型的宽高计算方式是包含内边距和边框的，是IE盒模型（border-box）。\n因此，对于IE，怪异模式和标准模式下的盒模型宽高计算方式是不一样的；\n行内元素的垂直对齐：\n很多早期的浏览器对齐图片至包含它们的盒子的下边框，目前CSS的规范要求它们被对齐至盒内文本的基线。\n目前标准模式下，基于Gecko的浏览器将会对齐至基线，而在quirks模式下它们会对齐至底部。\n最直接的例子就是图片的显示。标准模式下，图片是基线对齐的，图片与父元素下边框之间存在一点小空隙。而怪异模式下，图片是与父元素的下边框对齐的，则不存在这个问题。\n参考 浏览器的标准模式与怪异模式\nDOCTYPE声明作用及用法详解\n","date":"2020-11-07","permalink":"https://heeeyueee.github.io/post/doctype%E5%A3%B0%E6%98%8E%E7%9A%84%E4%BD%9C%E7%94%A8/","tags":["HTML"],"title":"DOCTYPE声明的作用"},{"content":" 列表标签,\u0026lt;img\u0026gt;图像标签,链接标签,\u0026lt;table\u0026gt;表格标签,\u0026lt;form\u0026gt; 表单标签,\u0026lt;input\u0026gt; 标签\n 列表标签   \u0026lt;ol\u0026gt; —— ordered list\n\u0026lt;ol\u0026gt;标签是一个有序列表容器（ordered list），会在内部的列表项前面产生数字编号。\n 用法   常规用法  \u0026lt;ol\u0026gt;\r\u0026lt;li\u0026gt;列表项 A\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;列表项 B\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;列表项 C\u0026lt;/li\u0026gt;\r\u0026lt;/ol\u0026gt;\r 嵌套用法  \u0026lt;ol\u0026gt;标签内部可以嵌套\u0026lt;ol\u0026gt;标签或\u0026lt;ul\u0026gt;标签，形成多级列表  属性   reversed  reversed属性产生倒序的数字列表\nstart  start属性的值是一个整数，表示数字列表的起始编号。\ntype  type属性指定数字编号的样式。目前，浏览器支持以下样式。\na：小写字母\nA：大写字母\ni：小写罗马数字\nI：大写罗马数字\n1：整数（默认值）\n  \u0026lt;ul\u0026gt; —— unordered list\n\u0026lt;ul\u0026gt;标签是一个无序列表容器（unordered list），会在内部的列表项前面产生实心小圆点，作为列表符号。\n 用法  \u0026lt;ul\u0026gt;标签内部可以嵌套\u0026lt;ul\u0026gt;或\u0026lt;ol\u0026gt;，形成多级列表。\n  \u0026lt;li\u0026gt; —— list item\n\u0026lt;li\u0026gt;表示列表项，用在\u0026lt;ol\u0026gt;或\u0026lt;ul\u0026gt;容器之中。\n有序列表\u0026lt;ol\u0026gt;之中，\u0026lt;li\u0026gt;有一个value属性，定义当前列表项的编号，后面列表项会从这个值开始编号。\n  \u0026lt;img\u0026gt;图像标签   简介\n\u0026lt;img\u0026gt;默认是一个行内元素，与前后的文字处在同一行。\u0026lt;img\u0026gt;可以放在\u0026lt;a\u0026gt;标签内部，使得图片变成一个可以点击的链接。\n  属性\n   src  src属性指定图片的网址,可以是绝对URL，也可以是相对URL\nalt  alt属性用来设定图片的文字说明。图片不显示时（比如下载失败，或用户关闭图片加载），图片的位置上会显示该文本。\nwidth属性 height属性  图片默认以原始大小插入网页，width属性和height属性可以指定图片显示时的宽度和高度，单位是像素或百分比。\nsrcset、sizes(详见MDN)  srcset属性用来指定多张图像，适应不同像素密度的屏幕sizes属性用来不同尺寸的屏幕，显示不同大小的图像\n链接标签  \u0026lt;a\u0026gt;   属性    href\n 网址 href=\u0026quot;//www.example.com/\u0026quot;(浏览器会自动匹配)\n路径 href=\u0026quot;./index.md\u0026quot;\n伪协议 href=\u0026ldquo;javascript:void(0);\u0026quot;(去除默认跳转)\nid href=\u0026quot;#xxx\u0026rdquo; 跳转到内部元素\n   target\ntarget属性指定如何展示打开的链接。它可以是在指定的窗口打开 使用target属性的时候，最好跟rel=\u0026ldquo;noreferrer\u0026quot;一起使用，这样可以避免安全风险。\n _self：当前窗口打开，这是默认值\n_blank：新窗口打开\n_parent：上层窗口打开，这通常用于从父窗口打开的子窗口\n_top：顶层窗口打开。\n   rel\nrel属性说明链接与当前页面的关系。\n noopener：告诉浏览器打开链接时，不让链接窗口通过 JavaScript 的window.opener属性引用原始窗口，这样就提高了安全性。\nnoreferrer：告诉浏览器打开链接时，不要将当前网址作为 HTTP 头信息的Referer字段发送出去，这样可以隐藏点击的来源\n   download\ndownload属性表明当前链接用于下载，而不是跳转到另一个 URL。 如果download属性设置了值，那么这个值就是下载的文件名。\n\u0026lt;a href=\u0026quot;foo.exe\u0026quot; download=\u0026quot;bar.exe\u0026quot;\u0026gt;点击下载\u0026lt;/a\u0026gt;\r     \u0026lt;link\u0026gt; \u0026lt;link\u0026gt;标签主要用于将当前网页与相关的外部资源联系起来，通常放在\u0026lt;head\u0026gt;元素里面。最常见的用途就是加载 CSS 样式表。\n\u0026lt;link rel=\u0026quot;stylesheet\u0026quot; type=\u0026quot;text/css\u0026quot; href=\u0026quot;theme.css\u0026quot;\u0026gt;\r   \u0026lt;table\u0026gt;表格标签   \u0026lt;table\u0026gt;\n\u0026lt;table\u0026gt;是一个块级容器标签，所有表格内容都要放在这个标签里面。\n  \u0026lt;caption\u0026gt;\n\u0026lt;caption\u0026gt;总是\u0026lt;table\u0026gt;里面的第一个子元素，表示表格的标题。该元素是可选的。\n  \u0026lt;thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tfoot\u0026gt;\n\u0026lt;thead\u0026gt;、\u0026lt;tbody\u0026gt;、\u0026lt;tfoot\u0026gt;都是块级容器元素，且都是\u0026lt;table\u0026gt;的一级子元素，分别表示表头、表体和表尾。\n  \u0026lt;tr\u0026gt;——table row\n\u0026lt;tr\u0026gt;标签表示表格的一行（table row）\n  \u0026lt;th\u0026gt; \u0026lt;td\u0026gt;——table data\n\u0026lt;th\u0026gt;和\u0026lt;td\u0026gt;都用来定义表格的单元格。其中，\u0026lt;th\u0026gt;是标题单元格，\u0026lt;td\u0026gt;是数据单元格。\n 属性   colspan属性，rowspan属性  单元格会有跨越多行或多列的情况，这要通过colspan属性和rowspan属性设置，前者表示单元格跨越的栏数，后者表示单元格跨越的行数。\nscope属性  scope属性只有\u0026lt;th\u0026gt;标签支持，一般不在\u0026lt;td\u0026gt;标签使用，表示该\u0026lt;th\u0026gt;单元格到底是栏的标题，还是列的标题。取值：row（行）、col（列）\n使用举例\n  \u0026lt;form\u0026gt; 表单标签 \u0026lt;input\u0026gt; 标签 ","date":"2020-11-07","permalink":"https://heeeyueee.github.io/post/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/","tags":["HTML"],"title":"HTML常用标签"},{"content":" 超文本标记语言（英语：HyperText Markup Language，简称：HTML）是一种用于创建网页的标准标记语言。\n HTML的历史 HTML的首个公开描述出现于一个名为HTML Tags 页面存档备份，存于互联网档案馆的文件中，由蒂姆·伯纳斯-李于1991年底提及。它描述18个元素，包括HTML初始的、相对简单的设计。它的最大特点就是支持超链接，点击链接就可以跳转到其他网页，从而构成了整个互联网。\n2004年，网页超文本应用技术工作小组（WHATWG）开始开发HTML5，并在2008年与W3C共同交付，2014年10月28日完成标准化。\nHTML 起手 \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;zh-CN\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1.0\u0026quot;\u0026gt;\r\u0026lt;meta http-equiv=\u0026quot;X-UA-Compatible\u0026quot; content=\u0026quot;ie=edge\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r   \u0026lt;!DOCTYPE \u0026gt;标签:文档类型，告诉浏览器如何解析网页\n  \u0026lt;html\u0026gt;标签:网页的顶层容器，即标签树结构的顶层节点，也称为根元素（root element），其他元素都是它的子元素。一个网页只能有一个\u0026lt;html\u0026gt;标签。lang属性，表示网页内容默认的语言。\n  \u0026lt;head\u0026gt;标签:容器标签，用于放置网页的元信息。它的内容不会出现在网页上，而是为网页渲染提供额外信息。\n   \u0026lt;head\u0026gt;子元素 作用     \u0026lt;meta\u0026gt;  设置网页的元数据   \u0026lt;link\u0026gt;  连接外部样式表   \u0026lt;title\u0026gt;  设置网页标题   \u0026lt;style\u0026gt;  放置内嵌的样式表   \u0026lt;script\u0026gt; 引入脚本   \u0026lt;noscript\u0026gt; 浏览器不支持脚本时，所要显示的内容   \u0026lt;base\u0026gt;  设置网页内部相对 URL 的计算基准      \u0026lt;meta\u0026gt;标签:设置或说明网页的元数据，必须放在\u0026lt;head\u0026gt;里面。一个\u0026lt;meta\u0026gt;标签就是一项元数据，网页可以有多个\u0026lt;meta\u0026gt;。\u0026lt;meta\u0026gt;标签约定放在\u0026lt;head\u0026gt;内容的最前面。上面代码中：第一个\u0026lt;meta\u0026gt;标签表示网页采用 UTF-8 格式编码，第二个\u0026lt;meta\u0026gt;标签表示网页在手机端可以自动缩放。\n   \u0026lt;meta\u0026gt;标签属性 作用     name 属性 表示元数据的名字   content 属性 表示元数据的值   http-equiv 属性 用来覆盖 HTTP 回应的头信息字段(与content属性一起使用)   charset属性 指定网页的编码方式 \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt;       \u0026lt;title\u0026gt;标签:用于指定网页的标题，会显示在浏览器窗口的标题栏。\n  \u0026lt;body\u0026gt;标签:是一个容器标签，用于放置网页的主体内容。浏览器显示的页面内容，都放置在它的内部。它是\u0026lt;html\u0026gt;的第二个子元素，紧跟在\u0026lt;head\u0026gt;后面。\n   **ps:**怎样设置VS code的模板代码\nsettings——用户代码片段——搜索HTML.json——配置\n body中常用章节标签 \u0026lt;body\u0026gt;\r\u0026lt;header\u0026gt;页眉\u0026lt;/header\u0026gt;\r\u0026lt;main\u0026gt;\r\u0026lt;article\u0026gt;\r\u0026lt;h1\u0026gt;文章标题\u0026lt;/h1\u0026gt;\r\u0026lt;p\u0026gt;文章内容\u0026lt;/p\u0026gt;\r\u0026lt;/article\u0026gt;\r\u0026lt;/main\u0026gt;\r\u0026lt;footer\u0026gt;页尾\u0026lt;/footer\u0026gt;\r\u0026lt;/body\u0026gt;\r  \u0026lt;header\u0026gt;:表示一篇文章或者一个区块的头部 \u0026lt;footer\u0026gt;:表示网页、文章或章节的尾部 \u0026lt;main\u0026gt;:标签表示页面的主体内容，一个页面只能有一个\u0026lt;main\u0026gt; \u0026lt;main\u0026gt;是顶层标签，不能放置在\u0026lt;header\u0026gt;、\u0026lt;footer\u0026gt;、\u0026lt;article\u0026gt;、\u0026lt;aside\u0026gt;、\u0026lt;nav\u0026gt;等标签之中。 \u0026lt;article\u0026gt;:表示页面里面一段完整的内容 \u0026lt;aside\u0026gt;:标签用来放置网页侧边栏或与网页、文章主要内容间接相关的部分 \u0026lt;section\u0026gt;:表示一个含有主题的独立部分，通常用在文档里面表示一个章节 \u0026lt;nav\u0026gt;:标签用于放置页面或文档的导航信息，往往放置在\u0026lt;header\u0026gt;里面 \u0026lt;h1\u0026gt;~\u0026lt;h6\u0026gt;:HTML 提供了6个标签，用来表示文章的标题。按照标题的等级，一共分成六级。  body中常用文本标签   \u0026lt;div\u0026gt;:一个通用标签，表示一个区块（division）\n  \u0026lt;p\u0026gt;:是一个块级元素，代表文章的一个段落（paragraph）\n  \u0026lt;span\u0026gt;:一个通用目的的行内标签（即不会产生换行），不带有任何语义\n  \u0026lt;br\u0026gt;:换行符，单独使用的，没有闭合标签\nPS：HTML空格和换行处理规则\n 标签内容的头部和尾部的空格，一律忽略不计\n标签内容里面的多个连续空格（包含制表符\\t），会被浏览器合并成一个\n浏览器还会将文本里面的换行符（\\n）和回车符（\\r），替换成空格\n   \u0026lt;hr\u0026gt;:水平线分割线,单独使用的，没有闭合标签\n  \u0026lt;pre\u0026gt;:一个块级元素，表示保留原来的格式（preformatted），即浏览器会保留该标签内部原始的换行和空格。 PS: HTML 标签在\u0026lt;pre\u0026gt;里面还是起作用的。\u0026lt;pre\u0026gt;只保留空格和换行，不会保留 HTML标签 **\n与code标签一起使用\n  \u0026lt;strong\u0026gt;:以粗体显示内容,表示内容本身的重要性\n  \u0026lt;em\u0026gt;:以斜体显示它包含的内容,表示语气上的强调\n  \u0026lt;code\u0026gt;:一个行内元素，表示标签内容是计算机代码，浏览器默认会以等宽字体显示。\n  \u0026lt;blockquote\u0026gt;:是一个块级标签，表示引用,cite属性，它的值是一个网址，表示引言来源，不会显示在网页上 *\u0026lt;q\u0026gt;:是一个行内标签，也表示引用。它与\u0026lt;blockquote\u0026gt;的区别，就是它不会产生换行。\n  HTML常用行级标签和块级标签  行级标签:可以和其他元素保持在同一行，不可以自动换行，但不能设置宽高 块级标签:不可以和其他元素保持在同一行（独占一行），可以自动换行，能设置宽高 嵌套规则:块标签可以套行标签，行标签不可以套块标签。P标签不要套块属性标签，可以套a，span，文本    块级标签 行级标签     \u0026lt;article\u0026gt; \u0026lt;b\u0026gt;   \u0026lt;aside\u0026gt;  \u0026lt;em\u0026gt;   \u0026lt;blockquote\u0026gt;  \u0026lt;strong\u0026gt;   \u0026lt;div\u0026gt;  \u0026lt;i\u0026gt;   \u0026lt;dl\u0026gt; \u0026lt;a\u0026gt;   \u0026lt;footer\u0026gt;  \u0026lt;br\u0026gt;   \u0026lt;form\u0026gt;  \u0026lt;img\u0026gt;   \u0026lt;h1\u0026gt;~\u0026lt;h6\u0026gt;  \u0026lt;q\u0026gt;   \u0026lt;header\u0026gt;  \u0026lt;span\u0026gt;   \u0026lt;hgroup\u0026gt;  \u0026lt;button\u0026gt;   \u0026lt;hr\u0026gt;  \u0026lt;input\u0026gt;   \u0026lt;ol\u0026gt;  \u0026lt;label\u0026gt;   \u0026lt;p\u0026gt;  \u0026lt;select\u0026gt;   \u0026lt;section\u0026gt;  \u0026lt;code\u0026gt;   \u0026lt;table\u0026gt;  \u0026lt;abbr\u0026gt;   \u0026lt;ul\u0026gt;  \u0026amp;nbsp   \u0026lt;video\u0026gt;  \u0026amp;copy      元素的属性 网页元素的属性（attribute）可以定制元素的行为，不同的属性会导致元素有不同的行为。元素属性的写法是 HTML 标签内部的“键值对”。\n 属性名与标签名一样，不区分大小写，lang和LANG是同一个属性。 属性名与属性值之间，通过等号=连接。属性值可以放在单引号或双引号之中，建议统一使用双引号。某些属性值可以不使用引号，但是建议不要这样写。 有些属性是布尔属性，属性值可以省略，只要添加了属性名，就表示打开该属性。如：checked、hidden  全局属性\n全局属性（global attributes）是所有元素都可以使用的属性。\n id:属性是元素在网页内的唯一标识符,慎用,html不会纠错重复的id class:属性用来对网页元素进行分类。元素可以同时具有多个 class，它们之间使用空格分隔 title:属性用来为元素添加附加说明。鼠标悬浮在元素上面时，会将title属性值作为浮动提示，显示出来。 tabindex:控制 Tab 键遍历网页元素的顺序。  0，表示最后才被 tab 访问 -1，表示不可被 tab 访问 正整数， 网页元素按照从小到大的顺序（1、2、3、……），参与 Tab 键的遍历。   style:指定当前元素的 CSS 样式 accesskey:指定网页元素获得焦点的快捷键 hidden:一个布尔属性，表示当前的网页元素不再跟页面相关，因此浏览器不会渲染这个元素，所以就不会在网页中看到它 dir:属性表示文字的阅读方向  ltr：从左到右阅读，比如英语。 rtl：从右到左阅读 auto：浏览器根据内容的解析结果，自行决定   contenteditable:contenteditable属性允许用户修改内容。它有两个可能的值。  true或空字符串：内容可以编辑 false：不可以编辑    HTML5验证器  安装检查工具validator $ yarn global add node-w3c-validator\r  在VS code的终端通过命令使用 node-w3c-validator -i 被检查的HTMl文件.html\r   取消HTML标签默认属性样式 cssreset.css\n* {\rmargin: 0;\rpadding: 0;\rbox-sizing: border-box;\r}\r*::before,\r*::after {\rbox-sizing: border-box;\r}\ra {\rcolor: inherit;\rtext-decoration: none;\r}\rinput,\rbutton {\rfont-family: inherit;\r}\rol,\rul {\rlist-style: none;\r}\rtable {\rborder-collapse: collapse;\rborder-spacing: 0;\r}\r","date":"2020-11-06","permalink":"https://heeeyueee.github.io/post/html%E5%85%A5%E9%97%A8/","tags":["HTML"],"title":"HTML入门"},{"content":" 记录一下搭建过程\n 步骤：   使用scoop安装Hugo\n Scoop安装、配置与使用  Scoop是Windows的命令行安装程序，是一个强大的包管理工具。\n安装 在Cmder的PowerShell中运行以下命令\nInvoke-Expression (New-Object System.Net.WebClient).DownloadString('https://get.scoop.sh')  输入scoop help验证是否成功 截图 配置 在cmd命令行中执行以下命令更改scoop安装路径\n将Scoop安装到自定义目录(命令行方式)\n$env:SCOOP='D:\\Applications\\Scoop' [Environment]::SetEnvironmentVariable('SCOOP', $env:SCOOP, 'User')  将Scoop安装到自定义目录(命令行方式)\n$env:SCOOP_GLOBAL='F:\\GlobalScoopApps' [Environment]::SetEnvironmentVariable('SCOOP_GLOBAL', $env:SCOOP_GLOBAL, 'Machine')  也可以手动更改目录 使用  安装aria2以加快scoop下载软件的速度  scoop install aria2   下载hugo   scoop install hugo-extended  截图 hugo的安装路径\nD:\\Applications\\Scoop\\apps\\hugo-extended\\0.77.0\n     使用Hugo快速生成站点\n 使用cmd命令行工具,在hugo的安装路径下执行命令：  $ hugo new site D:\\hugoblog\\heeeyueee(生成站点的目录)     安装主题  在站点目录的themes文件夹中使用git clone命令下载主题  $ git clone https://github.com/CaiJimmy/hugo-theme-stack.git   依照主题配置config.toml文件，新建assets文件夹(慢慢研究) 运行Hugo  $ hugo server --theme=hugo-theme-stack --buildDrafts     部署  首先在GitHub上创建一个Repository，命名为：heeeyueee.github.io 在站点根目录执行 Hugo 命令生成最终页面：  $ hugo --theme=hyde --baseUrl=\u0026quot;http://heeeyueee.github.io/\u0026quot; (或者直接打开config文件修改baseUrl 再运行 Hugo 命令)   将pubilc目录里所有文件 push 到刚创建的Repository的 main 分支  $ cd public $ git init $ git remote add origin https://github.com/heeeyueee/heeeyueee.github.io.git $ git add -A $ git commit -m \u0026quot;first commit\u0026quot; $ git branch -M main $ git push -u origin main   浏览器访问：http://heeeyueee.github.io/,成功！    写博客   使用hugo命令来创建文章目录\n$ hugo new post/first.md  ps:去掉文章头部的 draft=true\n  在文章目录中存放文章所需图片，markdown语法引入PicGo图床生成的图片\n  使用hugo命令来更新文章(把hugo命令设为全局变量)\nhugo --theme=hugo-theme-fuji --baseUrl=\u0026quot;https://heeeyueee.github.io/\u0026quot;    summary 希望自己能认真记录（词穷人太难了）\n用到的链接  fuji主题文档 Hugo中文文档 知乎文章 scoop的安装配置与使用 PicGo图床 ","date":"2020-11-05","permalink":"https://heeeyueee.github.io/post/first/","tags":["博客搭建"],"title":"First"}]